"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_auth_ts"],{

/***/ "(app-pages-browser)/./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// shim for using process in browser\n\nvar process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;\nvar cachedClearTimeout;\nfunction defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while(len){\n        currentQueue = queue;\n        queue = [];\n        while(++queueIndex < len){\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nprocess.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for(var i = 1; i < arguments.length; i++){\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n_c = Item;\nItem.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nprocess.title = \"browser\";\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \"\"; // empty string to avoid regexp issues\nprocess.versions = {};\nfunction noop() {}\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\nprocess.listeners = function(name) {\n    return [];\n};\nprocess.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\nprocess.cwd = function() {\n    return \"/\";\n};\nprocess.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\nprocess.umask = function() {\n    return 0;\n};\nvar _c;\n$RefreshReg$(_c, \"Item\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0NBQW9DOztBQUNwQyxJQUFJQSxVQUFVQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQztBQUVoQywyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLCtFQUErRTtBQUMvRSw4REFBOEQ7QUFFOUQsSUFBSUM7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ0wsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBQ0EsU0FBU0M7SUFDTCxNQUFNLElBQUlELE1BQU07QUFDcEI7QUFDQztJQUNHLElBQUk7UUFDQSxJQUFJLE9BQU9FLGVBQWUsWUFBWTtZQUNsQ0wsbUJBQW1CSztRQUN2QixPQUFPO1lBQ0hMLG1CQUFtQkU7UUFDdkI7SUFDSixFQUFFLE9BQU9JLEdBQUc7UUFDUk4sbUJBQW1CRTtJQUN2QjtJQUNBLElBQUk7UUFDQSxJQUFJLE9BQU9LLGlCQUFpQixZQUFZO1lBQ3BDTixxQkFBcUJNO1FBQ3pCLE9BQU87WUFDSE4scUJBQXFCRztRQUN6QjtJQUNKLEVBQUUsT0FBT0UsR0FBRztRQUNSTCxxQkFBcUJHO0lBQ3pCO0FBQ0o7QUFDQSxTQUFTSSxXQUFXQyxHQUFHO0lBQ25CLElBQUlULHFCQUFxQkssWUFBWTtRQUNqQyx1Q0FBdUM7UUFDdkMsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNULHFCQUFxQkUsb0JBQW9CLENBQUNGLGdCQUFlLEtBQU1LLFlBQVk7UUFDNUVMLG1CQUFtQks7UUFDbkIsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLElBQUk7UUFDQSxzRUFBc0U7UUFDdEUsT0FBT1QsaUJBQWlCUyxLQUFLO0lBQ2pDLEVBQUUsT0FBTUgsR0FBRTtRQUNOLElBQUk7WUFDQSxrSEFBa0g7WUFDbEgsT0FBT04saUJBQWlCVSxJQUFJLENBQUMsTUFBTUQsS0FBSztRQUM1QyxFQUFFLE9BQU1ILEdBQUU7WUFDTixpS0FBaUs7WUFDakssT0FBT04saUJBQWlCVSxJQUFJLENBQUMsSUFBSSxFQUFFRCxLQUFLO1FBQzVDO0lBQ0o7QUFHSjtBQUNBLFNBQVNFLGdCQUFnQkMsTUFBTTtJQUMzQixJQUFJWCx1QkFBdUJNLGNBQWM7UUFDckMsdUNBQXVDO1FBQ3ZDLE9BQU9BLGFBQWFLO0lBQ3hCO0lBQ0EsMERBQTBEO0lBQzFELElBQUksQ0FBQ1gsdUJBQXVCRyx1QkFBdUIsQ0FBQ0gsa0JBQWlCLEtBQU1NLGNBQWM7UUFDckZOLHFCQUFxQk07UUFDckIsT0FBT0EsYUFBYUs7SUFDeEI7SUFDQSxJQUFJO1FBQ0Esc0VBQXNFO1FBQ3RFLE9BQU9YLG1CQUFtQlc7SUFDOUIsRUFBRSxPQUFPTixHQUFFO1FBQ1AsSUFBSTtZQUNBLG1IQUFtSDtZQUNuSCxPQUFPTCxtQkFBbUJTLElBQUksQ0FBQyxNQUFNRTtRQUN6QyxFQUFFLE9BQU9OLEdBQUU7WUFDUCxrS0FBa0s7WUFDbEssNEVBQTRFO1lBQzVFLE9BQU9MLG1CQUFtQlMsSUFBSSxDQUFDLElBQUksRUFBRUU7UUFDekM7SUFDSjtBQUlKO0FBQ0EsSUFBSUMsUUFBUSxFQUFFO0FBQ2QsSUFBSUMsV0FBVztBQUNmLElBQUlDO0FBQ0osSUFBSUMsYUFBYSxDQUFDO0FBRWxCLFNBQVNDO0lBQ0wsSUFBSSxDQUFDSCxZQUFZLENBQUNDLGNBQWM7UUFDNUI7SUFDSjtJQUNBRCxXQUFXO0lBQ1gsSUFBSUMsYUFBYUcsTUFBTSxFQUFFO1FBQ3JCTCxRQUFRRSxhQUFhSSxNQUFNLENBQUNOO0lBQ2hDLE9BQU87UUFDSEcsYUFBYSxDQUFDO0lBQ2xCO0lBQ0EsSUFBSUgsTUFBTUssTUFBTSxFQUFFO1FBQ2RFO0lBQ0o7QUFDSjtBQUVBLFNBQVNBO0lBQ0wsSUFBSU4sVUFBVTtRQUNWO0lBQ0o7SUFDQSxJQUFJTyxVQUFVYixXQUFXUztJQUN6QkgsV0FBVztJQUVYLElBQUlRLE1BQU1ULE1BQU1LLE1BQU07SUFDdEIsTUFBTUksSUFBSztRQUNQUCxlQUFlRjtRQUNmQSxRQUFRLEVBQUU7UUFDVixNQUFPLEVBQUVHLGFBQWFNLElBQUs7WUFDdkIsSUFBSVAsY0FBYztnQkFDZEEsWUFBWSxDQUFDQyxXQUFXLENBQUNPLEdBQUc7WUFDaEM7UUFDSjtRQUNBUCxhQUFhLENBQUM7UUFDZE0sTUFBTVQsTUFBTUssTUFBTTtJQUN0QjtJQUNBSCxlQUFlO0lBQ2ZELFdBQVc7SUFDWEgsZ0JBQWdCVTtBQUNwQjtBQUVBeEIsUUFBUTJCLFFBQVEsR0FBRyxTQUFVZixHQUFHO0lBQzVCLElBQUlnQixPQUFPLElBQUlDLE1BQU1DLFVBQVVULE1BQU0sR0FBRztJQUN4QyxJQUFJUyxVQUFVVCxNQUFNLEdBQUcsR0FBRztRQUN0QixJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUQsVUFBVVQsTUFBTSxFQUFFVSxJQUFLO1lBQ3ZDSCxJQUFJLENBQUNHLElBQUksRUFBRSxHQUFHRCxTQUFTLENBQUNDLEVBQUU7UUFDOUI7SUFDSjtJQUNBZixNQUFNZ0IsSUFBSSxDQUFDLElBQUlDLEtBQUtyQixLQUFLZ0I7SUFDekIsSUFBSVosTUFBTUssTUFBTSxLQUFLLEtBQUssQ0FBQ0osVUFBVTtRQUNqQ04sV0FBV1k7SUFDZjtBQUNKO0FBRUEsK0JBQStCO0FBQy9CLFNBQVNVLEtBQUtyQixHQUFHLEVBQUVzQixLQUFLO0lBQ3BCLElBQUksQ0FBQ3RCLEdBQUcsR0FBR0E7SUFDWCxJQUFJLENBQUNzQixLQUFLLEdBQUdBO0FBQ2pCO0tBSFNEO0FBSVRBLEtBQUtFLFNBQVMsQ0FBQ1QsR0FBRyxHQUFHO0lBQ2pCLElBQUksQ0FBQ2QsR0FBRyxDQUFDd0IsS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDRixLQUFLO0FBQ25DO0FBQ0FsQyxRQUFRcUMsS0FBSyxHQUFHO0FBQ2hCckMsUUFBUXNDLE9BQU8sR0FBRztBQUNsQnRDLFFBQVF1QyxHQUFHLEdBQUcsQ0FBQztBQUNmdkMsUUFBUXdDLElBQUksR0FBRyxFQUFFO0FBQ2pCeEMsUUFBUXlDLE9BQU8sR0FBRyxJQUFJLHNDQUFzQztBQUM1RHpDLFFBQVEwQyxRQUFRLEdBQUcsQ0FBQztBQUVwQixTQUFTQyxRQUFRO0FBRWpCM0MsUUFBUTRDLEVBQUUsR0FBR0Q7QUFDYjNDLFFBQVE2QyxXQUFXLEdBQUdGO0FBQ3RCM0MsUUFBUThDLElBQUksR0FBR0g7QUFDZjNDLFFBQVErQyxHQUFHLEdBQUdKO0FBQ2QzQyxRQUFRZ0QsY0FBYyxHQUFHTDtBQUN6QjNDLFFBQVFpRCxrQkFBa0IsR0FBR047QUFDN0IzQyxRQUFRa0QsSUFBSSxHQUFHUDtBQUNmM0MsUUFBUW1ELGVBQWUsR0FBR1I7QUFDMUIzQyxRQUFRb0QsbUJBQW1CLEdBQUdUO0FBRTlCM0MsUUFBUXFELFNBQVMsR0FBRyxTQUFVQyxJQUFJO0lBQUksT0FBTyxFQUFFO0FBQUM7QUFFaER0RCxRQUFRdUQsT0FBTyxHQUFHLFNBQVVELElBQUk7SUFDNUIsTUFBTSxJQUFJaEQsTUFBTTtBQUNwQjtBQUVBTixRQUFRd0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBQ3ZDeEQsUUFBUXlELEtBQUssR0FBRyxTQUFVQyxHQUFHO0lBQ3pCLE1BQU0sSUFBSXBELE1BQU07QUFDcEI7QUFDQU4sUUFBUTJELEtBQUssR0FBRztJQUFhLE9BQU87QUFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzVjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAPI: function() { return /* binding */ AuthAPI; },\n/* harmony export */   AuthStorage: function() { return /* binding */ AuthStorage; },\n/* harmony export */   WalletManager: function() { return /* binding */ WalletManager; },\n/* harmony export */   createAuthMessage: function() { return /* binding */ createAuthMessage; },\n/* harmony export */   generateChallenge: function() { return /* binding */ generateChallenge; },\n/* harmony export */   isValidEthereumAddress: function() { return /* binding */ isValidEthereumAddress; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// code/poc/frontend/lib/auth.ts\n// FIXED VERSION: Uses two-tier authentication endpoints\n// MODIFIED: Email auth disabled (Jan 2026) - phone/wallet only\n// Wallet detection and connection utilities\nclass WalletManager {\n    // Check if MetaMask is available\n    static isMetaMaskAvailable() {\n        return  true && typeof window.ethereum !== \"undefined\" && window.ethereum.isMetaMask;\n    }\n    // Connect to MetaMask\n    static async connectMetaMask() {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not found. Please install MetaMask browser extension.\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            console.log(\"\\uD83D\\uDD0C WalletManager: Starting MetaMask connection...\");\n            const addresses = await ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            console.log(\"\\uD83D\\uDD0C WalletManager: Received addresses:\", addresses);\n            if (!addresses || !Array.isArray(addresses) || addresses.length === 0) {\n                throw new Error(\"No accounts found. Please unlock MetaMask.\");\n            }\n            const address = addresses[0];\n            if (!address || typeof address !== \"string\" || address.trim() === \"\") {\n                throw new Error(\"Invalid address received from MetaMask.\");\n            }\n            const cleanedAddress = address.trim();\n            if (!/^0x[a-fA-F0-9]{40}$/.test(cleanedAddress)) {\n                throw new Error(\"Invalid Ethereum address format.\");\n            }\n            const lowercaseAddress = cleanedAddress.toLowerCase();\n            const walletInfo = {\n                address: lowercaseAddress,\n                publicKey: undefined,\n                provider: \"metamask\"\n            };\n            return walletInfo;\n        } catch (error) {\n            console.error(\"‚ùå WalletManager: Connection error:\", error);\n            throw new Error(\"Failed to connect MetaMask: \".concat(error.message));\n        }\n    }\n    // Sign a message with wallet\n    static async signMessage(message, address) {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not available\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            console.log(\"‚úçÔ∏è WalletManager: Signing message...\");\n            const signature = await ethereum.request({\n                method: \"personal_sign\",\n                params: [\n                    message,\n                    address\n                ]\n            });\n            console.log(\"‚úÖ WalletManager: Signature received\");\n            return signature;\n        } catch (error) {\n            console.error(\"‚ùå WalletManager: Message signing error:\", error);\n            throw new Error(\"Failed to sign message: \".concat(error.message));\n        }\n    }\n    // Listen for account changes\n    static onAccountsChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"accountsChanged\", callback);\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"accountsChanged\", callback);\n            }\n        };\n    }\n    // Listen for network changes\n    static onChainChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"chainChanged\", callback);\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"chainChanged\", callback);\n            }\n        };\n    }\n}\n// API base URL configuration\nconst getApiBaseUrl = ()=>{\n    const nextPublicUrl = \"https://redesigned-lamp-q74wgggqq9jjfxqjp-3001.app.github.dev/api\";\n    const reactAppUrl = process.env.REACT_APP_API_URL;\n    console.log(\"\\uD83D\\uDD27 lib/auth.ts Environment Check:\", {\n        NEXT_PUBLIC_API_URL: nextPublicUrl,\n        REACT_APP_API_URL: reactAppUrl,\n        NODE_ENV: \"development\"\n    });\n    const defaultUrl = nextPublicUrl || reactAppUrl;\n    if (!defaultUrl) {\n        if (true) {\n            const hostname = window.location.hostname;\n            if (hostname.includes(\"github.dev\") || hostname.includes(\"gitpod.io\")) {\n                const baseUrl = \"\".concat(window.location.protocol, \"//\").concat(hostname.replace(\"-3000\", \"-3001\"));\n                console.log(\"\\uD83D\\uDD17 lib/auth.ts: Detected Codespaces/Gitpod, using:\", baseUrl);\n                return baseUrl;\n            }\n        }\n        console.log(\"\\uD83D\\uDD17 lib/auth.ts: Using localhost:3001\");\n        return \"http://localhost:3001\";\n    }\n    const baseUrl = defaultUrl.replace(/\\/api.*$/, \"\");\n    console.log(\"\\uD83D\\uDD17 lib/auth.ts using API base URL:\", baseUrl);\n    return baseUrl;\n};\n// Authentication API client\nclass AuthAPI {\n    static get baseURL() {\n        return getApiBaseUrl();\n    }\n    // ‚úÖ FIXED: Generate authentication challenge using two-tier endpoint\n    static async getAuthChallenge(walletAddress) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/wallet/challenge\"); // ‚úÖ Changed from /auth/challenge\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Getting auth challenge from:\", fullUrl);\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Wallet address:\", walletAddress);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Challenge response status:\", response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"‚ùå lib/auth.ts: Challenge failed:\", response.status, errorText);\n                throw new Error(\"Failed to get auth challenge: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"‚úÖ lib/auth.ts: Challenge data received\");\n            if (data.success) {\n                return {\n                    challenge: data.challenge,\n                    timestamp: data.timestamp,\n                    nonce: data.nonce\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response from auth challenge\");\n            }\n        } catch (error) {\n            console.error(\"‚ùå lib/auth.ts: Auth challenge error:\", error);\n            throw error;\n        }\n    }\n    // ‚úÖ FIXED: Verify signature using two-tier endpoint\n    static async verifySignature(walletAddress, signature, challenge, timestamp, nonce) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/wallet/verify\"); // ‚úÖ Changed from /auth/login\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verifying signature at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress,\n                    signature,\n                    challenge,\n                    timestamp,\n                    nonce\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verify response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: response.statusText\n                    }));\n                console.error(\"‚ùå lib/auth.ts: Verify failed:\", errorData);\n                throw new Error(\"Authentication failed: \".concat(errorData.error || response.statusText));\n            }\n            const data = await response.json();\n            console.log(\"‚úÖ lib/auth.ts: Verify data received:\", data);\n            // ‚úÖ FIXED: Handle two-tier response format with all fields\n            if (data.success && data.token && data.user) {\n                return {\n                    token: data.token,\n                    user: {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.display_name,\n                        username: data.user.username,\n                        avatar_url: data.user.avatar_url,\n                        bio: data.user.bio,\n                        verification_status: data.user.verificationLevel || \"basic\",\n                        created_at: data.user.createdAt,\n                        // ‚úÖ Two-tier fields\n                        onboarding_completed: data.user.onboarding_completed,\n                        profileCompletion: data.user.profileCompletion,\n                        isNewUser: data.isNewUser,\n                        accountTier: data.user.accountTier,\n                        authMethod: data.user.authMethod\n                    }\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response from authentication\");\n            }\n        } catch (error) {\n            console.error(\"‚ùå lib/auth.ts: Signature verification error:\", error);\n            throw error;\n        }\n    }\n    // Get current user info\n    static async getCurrentUser(token) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/me\");\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Getting current user from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(token)\n                },\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to get user info: \".concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.success && data.user) {\n                return {\n                    id: data.user.id,\n                    address: data.user.walletAddress,\n                    email: data.user.email,\n                    display_name: data.user.display_name,\n                    username: data.user.username,\n                    avatar_url: data.user.avatar_url,\n                    verification_status: \"basic\",\n                    created_at: data.user.created_at,\n                    // Two-tier fields\n                    onboarding_completed: data.user.onboarding_completed,\n                    profileCompletion: data.user.profileCompletion,\n                    accountTier: data.user.accountTier,\n                    authMethod: data.user.authMethod\n                };\n            } else {\n                throw new Error(data.error || \"Invalid user data received\");\n            }\n        } catch (error) {\n            console.error(\"Get current user error:\", error);\n            throw error;\n        }\n    }\n    // ==========================================================================\n    // DISABLED: Email auth removed - phone/wallet only (Jan 2026)\n    // Email may be re-enabled later for: account recovery, 2FA, B2B restaurant portal\n    // To re-enable: uncomment these methods and corresponding backend routes in server.ts\n    // ==========================================================================\n    // // Email sign-up (two-tier endpoint)\n    // static async emailSignup(email: string, password: string, displayName?: string): Promise<{ token: string; user: User; isNewUser: boolean }> {\n    //   try {\n    //     console.log('üìß AuthAPI: Email sign-up request:', email);\n    //     const response = await fetch(`${this.baseURL}/api/auth/email/register`, {\n    //       method: 'POST',\n    //       headers: {\n    //         'Content-Type': 'application/json',\n    //       },\n    //       body: JSON.stringify({\n    //         email,\n    //         password,\n    //         display_name: displayName\n    //       }),\n    //     });\n    //     console.log('üìß AuthAPI: Sign-up response status:', response.status);\n    //     if (!response.ok) {\n    //       const errorData = await response.json().catch(() => ({}));\n    //       throw new Error(errorData.error || `Sign-up failed: ${response.status}`);\n    //     }\n    //     const data = await response.json();\n    //     console.log('‚úÖ AuthAPI: Email sign-up successful');\n    //     return {\n    //       token: data.token,\n    //       user: {\n    //         id: data.user.id,\n    //         email: data.user.email,\n    //         username: data.user.username,\n    //         display_name: data.user.display_name,\n    //         accountTier: data.user.accountTier,\n    //         authMethod: data.user.authMethod,\n    //         profileCompletion: data.user.profileCompletion,\n    //         onboarding_completed: data.user.onboarding_completed\n    //       },\n    //       isNewUser: data.isNewUser\n    //     };\n    //   } catch (error) {\n    //     console.error('‚ùå AuthAPI: Email sign-up error:', error);\n    //     throw error;\n    //   }\n    // }\n    // // Email login (two-tier endpoint)\n    // static async emailLogin(email: string, password: string): Promise<{ token: string; user: User; isNewUser: boolean }> {\n    //   try {\n    //     console.log('üìß AuthAPI: Email login request:', email);\n    //     const response = await fetch(`${this.baseURL}/api/auth/email/login`, {\n    //       method: 'POST',\n    //       headers: {\n    //         'Content-Type': 'application/json',\n    //       },\n    //       body: JSON.stringify({\n    //         email,\n    //         password\n    //       }),\n    //     });\n    //     console.log('üìß AuthAPI: Login response status:', response.status);\n    //     if (!response.ok) {\n    //       const errorData = await response.json().catch(() => ({}));\n    //       throw new Error(errorData.error || `Login failed: ${response.status}`);\n    //     }\n    //     const data = await response.json();\n    //     console.log('‚úÖ AuthAPI: Email login successful');\n    //     return {\n    //       token: data.token,\n    //       user: {\n    //         id: data.user.id,\n    //         email: data.user.email,\n    //         username: data.user.username,\n    //         display_name: data.user.display_name,\n    //         accountTier: data.user.accountTier,\n    //         authMethod: data.user.authMethod,\n    //         profileCompletion: data.user.profileCompletion,\n    //         onboarding_completed: data.user.onboarding_completed\n    //       },\n    //       isNewUser: data.isNewUser\n    //     };\n    //   } catch (error) {\n    //     console.error('‚ùå AuthAPI: Email login error:', error);\n    //     throw error;\n    //   }\n    // }\n    // Verify JWT token\n    static async verifyToken(token) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/verify\");\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Verifying token at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    token\n                })\n            });\n            if (!response.ok) {\n                return {\n                    valid: false\n                };\n            }\n            const data = await response.json();\n            if (data.success && data.valid) {\n                return {\n                    valid: true,\n                    user: data.user ? {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        email: data.user.email,\n                        display_name: data.user.display_name,\n                        username: data.user.username,\n                        verification_status: \"basic\",\n                        accountTier: data.user.accountTier,\n                        authMethod: data.user.authMethod\n                    } : undefined\n                };\n            } else {\n                return {\n                    valid: false\n                };\n            }\n        } catch (error) {\n            console.error(\"Token verification error:\", error);\n            return {\n                valid: false\n            };\n        }\n    }\n}\n// Local storage utilities\nclass AuthStorage {\n    static saveToken(token) {\n        if (true) {\n            localStorage.setItem(this.TOKEN_KEY, token);\n        }\n    }\n    static getToken() {\n        if (true) {\n            return localStorage.getItem(this.TOKEN_KEY);\n        }\n        return null;\n    }\n    static removeToken() {\n        if (true) {\n            localStorage.removeItem(this.TOKEN_KEY);\n        }\n    }\n    static saveUser(user) {\n        if (true) {\n            localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n        }\n    }\n    static getUser() {\n        if (true) {\n            const userData = localStorage.getItem(this.USER_KEY);\n            if (userData) {\n                try {\n                    return JSON.parse(userData);\n                } catch (error) {\n                    console.error(\"Failed to parse stored user data:\", error);\n                    this.removeUser();\n                }\n            }\n        }\n        return null;\n    }\n    static removeUser() {\n        if (true) {\n            localStorage.removeItem(this.USER_KEY);\n        }\n    }\n    static clear() {\n        this.removeToken();\n        this.removeUser();\n    }\n}\nAuthStorage.TOKEN_KEY = \"omeone_auth_token\";\nAuthStorage.USER_KEY = \"omeone_user\";\n// Utility functions\nconst createAuthMessage = (challenge, walletAddress)=>{\n    return challenge;\n};\nconst isValidEthereumAddress = (address)=>{\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n};\nconst generateChallenge = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUssTUFBTW1HLG9CQUFvQjtJQUMvQixPQUFPQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRyxNQUN4Q0gsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsTUFDeENDLEtBQUtDLEdBQUcsR0FBR0gsUUFBUSxDQUFDO0FBQzdCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2F1dGgudHM/YmY3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb2RlL3BvYy9mcm9udGVuZC9saWIvYXV0aC50c1xuLy8gRklYRUQgVkVSU0lPTjogVXNlcyB0d28tdGllciBhdXRoZW50aWNhdGlvbiBlbmRwb2ludHNcbi8vIE1PRElGSUVEOiBFbWFpbCBhdXRoIGRpc2FibGVkIChKYW4gMjAyNikgLSBwaG9uZS93YWxsZXQgb25seVxuXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LWhvdC10b2FzdCc7XG5cbi8vIFR5cGVzIGZvciBhdXRoZW50aWNhdGlvblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgZW1haWw/OiBzdHJpbmc7XG4gIHVzZXJuYW1lPzogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU/OiBzdHJpbmc7XG4gIGF2YXRhcl91cmw/OiBzdHJpbmc7XG4gIHZlcmlmaWNhdGlvbl9zdGF0dXM/OiAnYmFzaWMnIHwgJ3ZlcmlmaWVkJyB8ICdleHBlcnQnO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xuICAvLyBUd28tdGllciBmaWVsZHNcbiAgb25ib2FyZGluZ19jb21wbGV0ZWQ/OiBib29sZWFuO1xuICBwcm9maWxlQ29tcGxldGlvbj86IG51bWJlcjtcbiAgaXNOZXdVc2VyPzogYm9vbGVhbjtcbiAgYWNjb3VudFRpZXI/OiBzdHJpbmc7XG4gIGF1dGhNZXRob2Q/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFN0YXRlIHtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIHVzZXI6IFVzZXIgfCBudWxsO1xuICB0b2tlbjogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRJbmZvIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBwdWJsaWNLZXk/OiBzdHJpbmc7XG4gIHByb3ZpZGVyOiAnbWV0YW1hc2snIHwgJ3dhbGxldGNvbm5lY3QnIHwgJ2NvaW5iYXNlJyB8ICdtYW51YWwnO1xufVxuXG4vLyBXYWxsZXQgZGV0ZWN0aW9uIGFuZCBjb25uZWN0aW9uIHV0aWxpdGllc1xuZXhwb3J0IGNsYXNzIFdhbGxldE1hbmFnZXIge1xuICAvLyBDaGVjayBpZiBNZXRhTWFzayBpcyBhdmFpbGFibGVcbiAgc3RhdGljIGlzTWV0YU1hc2tBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIFxuICAgICAgICAgICB0eXBlb2YgKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAod2luZG93IGFzIGFueSkuZXRoZXJldW0uaXNNZXRhTWFzaztcbiAgfVxuXG4gIC8vIENvbm5lY3QgdG8gTWV0YU1hc2tcbiAgc3RhdGljIGFzeW5jIGNvbm5lY3RNZXRhTWFzaygpOiBQcm9taXNlPFdhbGxldEluZm8+IHtcbiAgICBpZiAoIXRoaXMuaXNNZXRhTWFza0F2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIG5vdCBmb3VuZC4gUGxlYXNlIGluc3RhbGwgTWV0YU1hc2sgYnJvd3NlciBleHRlbnNpb24uJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV0aGVyZXVtID0gKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UjCBXYWxsZXRNYW5hZ2VyOiBTdGFydGluZyBNZXRhTWFzayBjb25uZWN0aW9uLi4uJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SMIFdhbGxldE1hbmFnZXI6IFJlY2VpdmVkIGFkZHJlc3NlczonLCBhZGRyZXNzZXMpO1xuXG4gICAgICBpZiAoIWFkZHJlc3NlcyB8fCAhQXJyYXkuaXNBcnJheShhZGRyZXNzZXMpIHx8IGFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZC4gUGxlYXNlIHVubG9jayBNZXRhTWFzay4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3Nlc1swXTtcbiAgICAgIFxuICAgICAgaWYgKCFhZGRyZXNzIHx8IHR5cGVvZiBhZGRyZXNzICE9PSAnc3RyaW5nJyB8fCBhZGRyZXNzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MgcmVjZWl2ZWQgZnJvbSBNZXRhTWFzay4nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xlYW5lZEFkZHJlc3MgPSBhZGRyZXNzLnRyaW0oKTtcbiAgICAgIFxuICAgICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChjbGVhbmVkQWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBsb3dlcmNhc2VBZGRyZXNzID0gY2xlYW5lZEFkZHJlc3MudG9Mb3dlckNhc2UoKTtcblxuICAgICAgY29uc3Qgd2FsbGV0SW5mbzogV2FsbGV0SW5mbyA9IHtcbiAgICAgICAgYWRkcmVzczogbG93ZXJjYXNlQWRkcmVzcyxcbiAgICAgICAgcHVibGljS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIHByb3ZpZGVyOiAnbWV0YW1hc2snXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gd2FsbGV0SW5mbztcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgV2FsbGV0TWFuYWdlcjogQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb25uZWN0IE1ldGFNYXNrOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2lnbiBhIG1lc3NhZ2Ugd2l0aCB3YWxsZXRcbiAgc3RhdGljIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2U6IHN0cmluZywgYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNNZXRhTWFza0F2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinI3vuI8gV2FsbGV0TWFuYWdlcjogU2lnbmluZyBtZXNzYWdlLi4uJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgcGFyYW1zOiBbbWVzc2FnZSwgYWRkcmVzc11cbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFdhbGxldE1hbmFnZXI6IFNpZ25hdHVyZSByZWNlaXZlZCcpO1xuXG4gICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBXYWxsZXRNYW5hZ2VyOiBNZXNzYWdlIHNpZ25pbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBhY2NvdW50IGNoYW5nZXNcbiAgc3RhdGljIG9uQWNjb3VudHNDaGFuZ2VkKGNhbGxiYWNrOiAoYWRkcmVzc2VzOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBldGhlcmV1bSA9ICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bTtcbiAgICBldGhlcmV1bS5vbignYWNjb3VudHNDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZXRoZXJldW0gJiYgZXRoZXJldW0ucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgZXRoZXJldW0ucmVtb3ZlTGlzdGVuZXIoJ2FjY291bnRzQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBuZXR3b3JrIGNoYW5nZXNcbiAgc3RhdGljIG9uQ2hhaW5DaGFuZ2VkKGNhbGxiYWNrOiAoY2hhaW5JZDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgaWYgKCF0aGlzLmlzTWV0YU1hc2tBdmFpbGFibGUoKSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGV0aGVyZXVtID0gKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtO1xuICAgIGV0aGVyZXVtLm9uKCdjaGFpbkNoYW5nZWQnLCBjYWxsYmFjayk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChldGhlcmV1bSAmJiBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8gQVBJIGJhc2UgVVJMIGNvbmZpZ3VyYXRpb25cbmNvbnN0IGdldEFwaUJhc2VVcmwgPSAoKTogc3RyaW5nID0+IHtcbiAgY29uc3QgbmV4dFB1YmxpY1VybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gIGNvbnN0IHJlYWN0QXBwVXJsID0gcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0FQSV9VUkw7XG4gIFxuICBjb25zb2xlLmxvZygn8J+UpyBsaWIvYXV0aC50cyBFbnZpcm9ubWVudCBDaGVjazonLCB7XG4gICAgTkVYVF9QVUJMSUNfQVBJX1VSTDogbmV4dFB1YmxpY1VybCxcbiAgICBSRUFDVF9BUFBfQVBJX1VSTDogcmVhY3RBcHBVcmwsXG4gICAgTk9ERV9FTlY6IHByb2Nlc3MuZW52Lk5PREVfRU5WXG4gIH0pO1xuXG4gIGNvbnN0IGRlZmF1bHRVcmwgPSBuZXh0UHVibGljVXJsIHx8IHJlYWN0QXBwVXJsO1xuICBcbiAgaWYgKCFkZWZhdWx0VXJsKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgIGlmIChob3N0bmFtZS5pbmNsdWRlcygnZ2l0aHViLmRldicpIHx8IGhvc3RuYW1lLmluY2x1ZGVzKCdnaXRwb2QuaW8nKSkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHtob3N0bmFtZS5yZXBsYWNlKCctMzAwMCcsICctMzAwMScpfWA7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SXIGxpYi9hdXRoLnRzOiBEZXRlY3RlZCBDb2Rlc3BhY2VzL0dpdHBvZCwgdXNpbmc6JywgYmFzZVVybCk7XG4gICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZygn8J+UlyBsaWIvYXV0aC50czogVXNpbmcgbG9jYWxob3N0OjMwMDEnKTtcbiAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gIH1cbiAgXG4gIGNvbnN0IGJhc2VVcmwgPSBkZWZhdWx0VXJsLnJlcGxhY2UoL1xcL2FwaS4qJC8sICcnKTtcbiAgY29uc29sZS5sb2coJ/CflJcgbGliL2F1dGgudHMgdXNpbmcgQVBJIGJhc2UgVVJMOicsIGJhc2VVcmwpO1xuICBcbiAgcmV0dXJuIGJhc2VVcmw7XG59O1xuXG4vLyBBdXRoZW50aWNhdGlvbiBBUEkgY2xpZW50XG5leHBvcnQgY2xhc3MgQXV0aEFQSSB7XG4gIHByaXZhdGUgc3RhdGljIGdldCBiYXNlVVJMKCkge1xuICAgIHJldHVybiBnZXRBcGlCYXNlVXJsKCk7XG4gIH1cblxuICAvLyDinIUgRklYRUQ6IEdlbmVyYXRlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSB1c2luZyB0d28tdGllciBlbmRwb2ludFxuICBzdGF0aWMgYXN5bmMgZ2V0QXV0aENoYWxsZW5nZSh3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHsgY2hhbGxlbmdlOiBzdHJpbmc7IHRpbWVzdGFtcDogbnVtYmVyOyBub25jZTogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvd2FsbGV0L2NoYWxsZW5nZWA7ICAvLyDinIUgQ2hhbmdlZCBmcm9tIC9hdXRoL2NoYWxsZW5nZVxuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IEdldHRpbmcgYXV0aCBjaGFsbGVuZ2UgZnJvbTonLCBmdWxsVXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIGxpYi9hdXRoLnRzOiBXYWxsZXQgYWRkcmVzczonLCB3YWxsZXRBZGRyZXNzKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB3YWxsZXRBZGRyZXNzIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIGxpYi9hdXRoLnRzOiBDaGFsbGVuZ2UgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgbGliL2F1dGgudHM6IENoYWxsZW5nZSBmYWlsZWQ6JywgcmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgYXV0aCBjaGFsbGVuZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBsaWIvYXV0aC50czogQ2hhbGxlbmdlIGRhdGEgcmVjZWl2ZWQnKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWxsZW5nZTogZGF0YS5jaGFsbGVuZ2UsXG4gICAgICAgICAgdGltZXN0YW1wOiBkYXRhLnRpbWVzdGFtcCxcbiAgICAgICAgICBub25jZTogZGF0YS5ub25jZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ludmFsaWQgcmVzcG9uc2UgZnJvbSBhdXRoIGNoYWxsZW5nZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogQXV0aCBjaGFsbGVuZ2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8g4pyFIEZJWEVEOiBWZXJpZnkgc2lnbmF0dXJlIHVzaW5nIHR3by10aWVyIGVuZHBvaW50XG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlTaWduYXR1cmUoXG4gICAgd2FsbGV0QWRkcmVzczogc3RyaW5nLCBcbiAgICBzaWduYXR1cmU6IHN0cmluZywgXG4gICAgY2hhbGxlbmdlOiBzdHJpbmcsXG4gICAgdGltZXN0YW1wPzogbnVtYmVyLFxuICAgIG5vbmNlPzogc3RyaW5nXG4gICk6IFByb21pc2U8eyB0b2tlbjogc3RyaW5nOyB1c2VyOiBVc2VyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvd2FsbGV0L3ZlcmlmeWA7ICAvLyDinIUgQ2hhbmdlZCBmcm9tIC9hdXRoL2xvZ2luXG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogVmVyaWZ5aW5nIHNpZ25hdHVyZSBhdDonLCBmdWxsVXJsKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgICB3YWxsZXRBZGRyZXNzLCBcbiAgICAgICAgICBzaWduYXR1cmUsIFxuICAgICAgICAgIGNoYWxsZW5nZSxcbiAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgbm9uY2VcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IFZlcmlmeSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZXJyb3I6IHJlc3BvbnNlLnN0YXR1c1RleHQgfSkpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgbGliL2F1dGgudHM6IFZlcmlmeSBmYWlsZWQ6JywgZXJyb3JEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhLmVycm9yIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIGxpYi9hdXRoLnRzOiBWZXJpZnkgZGF0YSByZWNlaXZlZDonLCBkYXRhKTtcbiAgICAgIFxuICAgICAgLy8g4pyFIEZJWEVEOiBIYW5kbGUgdHdvLXRpZXIgcmVzcG9uc2UgZm9ybWF0IHdpdGggYWxsIGZpZWxkc1xuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnRva2VuICYmIGRhdGEudXNlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRva2VuOiBkYXRhLnRva2VuLFxuICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBkYXRhLnVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZGF0YS51c2VyLmRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBhdmF0YXJfdXJsOiBkYXRhLnVzZXIuYXZhdGFyX3VybCxcbiAgICAgICAgICAgIGJpbzogZGF0YS51c2VyLmJpbyxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbl9zdGF0dXM6IGRhdGEudXNlci52ZXJpZmljYXRpb25MZXZlbCB8fCAnYmFzaWMnLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogZGF0YS51c2VyLmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIC8vIOKchSBUd28tdGllciBmaWVsZHNcbiAgICAgICAgICAgIG9uYm9hcmRpbmdfY29tcGxldGVkOiBkYXRhLnVzZXIub25ib2FyZGluZ19jb21wbGV0ZWQsXG4gICAgICAgICAgICBwcm9maWxlQ29tcGxldGlvbjogZGF0YS51c2VyLnByb2ZpbGVDb21wbGV0aW9uLFxuICAgICAgICAgICAgaXNOZXdVc2VyOiBkYXRhLmlzTmV3VXNlciwgIC8vIOKchSBGcm9tIHRvcC1sZXZlbCByZXNwb25zZVxuICAgICAgICAgICAgYWNjb3VudFRpZXI6IGRhdGEudXNlci5hY2NvdW50VGllcixcbiAgICAgICAgICAgIGF1dGhNZXRob2Q6IGRhdGEudXNlci5hdXRoTWV0aG9kXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ludmFsaWQgcmVzcG9uc2UgZnJvbSBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgY3VycmVudCB1c2VyIGluZm9cbiAgc3RhdGljIGFzeW5jIGdldEN1cnJlbnRVc2VyKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvbWVgO1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gbGliL2F1dGgudHM6IEdldHRpbmcgY3VycmVudCB1c2VyIGZyb206JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB1c2VyIGluZm86ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxuICAgICAgICAgIGFkZHJlc3M6IGRhdGEudXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgIGVtYWlsOiBkYXRhLnVzZXIuZW1haWwsXG4gICAgICAgICAgZGlzcGxheV9uYW1lOiBkYXRhLnVzZXIuZGlzcGxheV9uYW1lLFxuICAgICAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgYXZhdGFyX3VybDogZGF0YS51c2VyLmF2YXRhcl91cmwsXG4gICAgICAgICAgdmVyaWZpY2F0aW9uX3N0YXR1czogJ2Jhc2ljJyxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBkYXRhLnVzZXIuY3JlYXRlZF9hdCxcbiAgICAgICAgICAvLyBUd28tdGllciBmaWVsZHNcbiAgICAgICAgICBvbmJvYXJkaW5nX2NvbXBsZXRlZDogZGF0YS51c2VyLm9uYm9hcmRpbmdfY29tcGxldGVkLFxuICAgICAgICAgIHByb2ZpbGVDb21wbGV0aW9uOiBkYXRhLnVzZXIucHJvZmlsZUNvbXBsZXRpb24sXG4gICAgICAgICAgYWNjb3VudFRpZXI6IGRhdGEudXNlci5hY2NvdW50VGllcixcbiAgICAgICAgICBhdXRoTWV0aG9kOiBkYXRhLnVzZXIuYXV0aE1ldGhvZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ludmFsaWQgdXNlciBkYXRhIHJlY2VpdmVkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignR2V0IGN1cnJlbnQgdXNlciBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBESVNBQkxFRDogRW1haWwgYXV0aCByZW1vdmVkIC0gcGhvbmUvd2FsbGV0IG9ubHkgKEphbiAyMDI2KVxuICAvLyBFbWFpbCBtYXkgYmUgcmUtZW5hYmxlZCBsYXRlciBmb3I6IGFjY291bnQgcmVjb3ZlcnksIDJGQSwgQjJCIHJlc3RhdXJhbnQgcG9ydGFsXG4gIC8vIFRvIHJlLWVuYWJsZTogdW5jb21tZW50IHRoZXNlIG1ldGhvZHMgYW5kIGNvcnJlc3BvbmRpbmcgYmFja2VuZCByb3V0ZXMgaW4gc2VydmVyLnRzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gLy8gRW1haWwgc2lnbi11cCAodHdvLXRpZXIgZW5kcG9pbnQpXG4gIC8vIHN0YXRpYyBhc3luYyBlbWFpbFNpZ251cChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCBkaXNwbGF5TmFtZT86IHN0cmluZyk6IFByb21pc2U8eyB0b2tlbjogc3RyaW5nOyB1c2VyOiBVc2VyOyBpc05ld1VzZXI6IGJvb2xlYW4gfT4ge1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICBjb25zb2xlLmxvZygn8J+TpyBBdXRoQVBJOiBFbWFpbCBzaWduLXVwIHJlcXVlc3Q6JywgZW1haWwpO1xuXG4gIC8vICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvZW1haWwvcmVnaXN0ZXJgLCB7XG4gIC8vICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAvLyAgICAgICBoZWFkZXJzOiB7XG4gIC8vICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgLy8gICAgICAgfSxcbiAgLy8gICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAvLyAgICAgICAgIGVtYWlsLFxuICAvLyAgICAgICAgIHBhc3N3b3JkLFxuICAvLyAgICAgICAgIGRpc3BsYXlfbmFtZTogZGlzcGxheU5hbWVcbiAgLy8gICAgICAgfSksXG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgY29uc29sZS5sb2coJ/Cfk6cgQXV0aEFQSTogU2lnbi11cCByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAvLyAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAvLyAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gIC8vICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYFNpZ24tdXAgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgLy8gICAgIH1cblxuICAvLyAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgLy8gICAgIGNvbnNvbGUubG9nKCfinIUgQXV0aEFQSTogRW1haWwgc2lnbi11cCBzdWNjZXNzZnVsJyk7XG5cbiAgLy8gICAgIHJldHVybiB7XG4gIC8vICAgICAgIHRva2VuOiBkYXRhLnRva2VuLFxuICAvLyAgICAgICB1c2VyOiB7XG4gIC8vICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgLy8gICAgICAgICBlbWFpbDogZGF0YS51c2VyLmVtYWlsLFxuICAvLyAgICAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXIudXNlcm5hbWUsXG4gIC8vICAgICAgICAgZGlzcGxheV9uYW1lOiBkYXRhLnVzZXIuZGlzcGxheV9uYW1lLFxuICAvLyAgICAgICAgIGFjY291bnRUaWVyOiBkYXRhLnVzZXIuYWNjb3VudFRpZXIsXG4gIC8vICAgICAgICAgYXV0aE1ldGhvZDogZGF0YS51c2VyLmF1dGhNZXRob2QsXG4gIC8vICAgICAgICAgcHJvZmlsZUNvbXBsZXRpb246IGRhdGEudXNlci5wcm9maWxlQ29tcGxldGlvbixcbiAgLy8gICAgICAgICBvbmJvYXJkaW5nX2NvbXBsZXRlZDogZGF0YS51c2VyLm9uYm9hcmRpbmdfY29tcGxldGVkXG4gIC8vICAgICAgIH0sXG4gIC8vICAgICAgIGlzTmV3VXNlcjogZGF0YS5pc05ld1VzZXJcbiAgLy8gICAgIH07XG4gIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBBdXRoQVBJOiBFbWFpbCBzaWduLXVwIGVycm9yOicsIGVycm9yKTtcbiAgLy8gICAgIHRocm93IGVycm9yO1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8vIC8vIEVtYWlsIGxvZ2luICh0d28tdGllciBlbmRwb2ludClcbiAgLy8gc3RhdGljIGFzeW5jIGVtYWlsTG9naW4oZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8eyB0b2tlbjogc3RyaW5nOyB1c2VyOiBVc2VyOyBpc05ld1VzZXI6IGJvb2xlYW4gfT4ge1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICBjb25zb2xlLmxvZygn8J+TpyBBdXRoQVBJOiBFbWFpbCBsb2dpbiByZXF1ZXN0OicsIGVtYWlsKTtcblxuICAvLyAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL2VtYWlsL2xvZ2luYCwge1xuICAvLyAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgLy8gICAgICAgaGVhZGVyczoge1xuICAvLyAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gIC8vICAgICAgIH0sXG4gIC8vICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgLy8gICAgICAgICBlbWFpbCxcbiAgLy8gICAgICAgICBwYXNzd29yZFxuICAvLyAgICAgICB9KSxcbiAgLy8gICAgIH0pO1xuXG4gIC8vICAgICBjb25zb2xlLmxvZygn8J+TpyBBdXRoQVBJOiBMb2dpbiByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAvLyAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAvLyAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gIC8vICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYExvZ2luIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gIC8vICAgICB9XG5cbiAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIC8vICAgICBjb25zb2xlLmxvZygn4pyFIEF1dGhBUEk6IEVtYWlsIGxvZ2luIHN1Y2Nlc3NmdWwnKTtcblxuICAvLyAgICAgcmV0dXJuIHtcbiAgLy8gICAgICAgdG9rZW46IGRhdGEudG9rZW4sXG4gIC8vICAgICAgIHVzZXI6IHtcbiAgLy8gICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxuICAvLyAgICAgICAgIGVtYWlsOiBkYXRhLnVzZXIuZW1haWwsXG4gIC8vICAgICAgICAgdXNlcm5hbWU6IGRhdGEudXNlci51c2VybmFtZSxcbiAgLy8gICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5kaXNwbGF5X25hbWUsXG4gIC8vICAgICAgICAgYWNjb3VudFRpZXI6IGRhdGEudXNlci5hY2NvdW50VGllcixcbiAgLy8gICAgICAgICBhdXRoTWV0aG9kOiBkYXRhLnVzZXIuYXV0aE1ldGhvZCxcbiAgLy8gICAgICAgICBwcm9maWxlQ29tcGxldGlvbjogZGF0YS51c2VyLnByb2ZpbGVDb21wbGV0aW9uLFxuICAvLyAgICAgICAgIG9uYm9hcmRpbmdfY29tcGxldGVkOiBkYXRhLnVzZXIub25ib2FyZGluZ19jb21wbGV0ZWRcbiAgLy8gICAgICAgfSxcbiAgLy8gICAgICAgaXNOZXdVc2VyOiBkYXRhLmlzTmV3VXNlclxuICAvLyAgICAgfTtcbiAgLy8gICB9IGNhdGNoIChlcnJvcikge1xuICAvLyAgICAgY29uc29sZS5lcnJvcign4p2MIEF1dGhBUEk6IEVtYWlsIGxvZ2luIGVycm9yOicsIGVycm9yKTtcbiAgLy8gICAgIHRocm93IGVycm9yO1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8vIFZlcmlmeSBKV1QgdG9rZW5cbiAgc3RhdGljIGFzeW5jIHZlcmlmeVRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW47IHVzZXI/OiBVc2VyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvdmVyaWZ5YDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIGxpYi9hdXRoLnRzOiBWZXJpZnlpbmcgdG9rZW4gYXQ6JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4gfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyID8ge1xuICAgICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEudXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgZW1haWw6IGRhdGEudXNlci5lbWFpbCxcbiAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZGF0YS51c2VyLmRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25fc3RhdHVzOiAnYmFzaWMnLFxuICAgICAgICAgICAgYWNjb3VudFRpZXI6IGRhdGEudXNlci5hY2NvdW50VGllcixcbiAgICAgICAgICAgIGF1dGhNZXRob2Q6IGRhdGEudXNlci5hdXRoTWV0aG9kXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBMb2NhbCBzdG9yYWdlIHV0aWxpdGllc1xuZXhwb3J0IGNsYXNzIEF1dGhTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgVE9LRU5fS0VZID0gJ29tZW9uZV9hdXRoX3Rva2VuJztcbiAgcHJpdmF0ZSBzdGF0aWMgVVNFUl9LRVkgPSAnb21lb25lX3VzZXInO1xuXG4gIHN0YXRpYyBzYXZlVG9rZW4odG9rZW46IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5UT0tFTl9LRVksIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0VG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5UT0tFTl9LRVkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVUb2tlbigpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2F2ZVVzZXIodXNlcjogVXNlcik6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5VU0VSX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRVc2VyKCk6IFVzZXIgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5VU0VSX0tFWSk7XG4gICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh1c2VyRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCB1c2VyIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlVXNlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIHJlbW92ZVVzZXIoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlVTRVJfS0VZKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5yZW1vdmVUb2tlbigpO1xuICAgIHRoaXMucmVtb3ZlVXNlcigpO1xuICB9XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgY3JlYXRlQXV0aE1lc3NhZ2UgPSAoY2hhbGxlbmdlOiBzdHJpbmcsIHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBjaGFsbGVuZ2U7XG59O1xuXG5leHBvcnQgY29uc3QgaXNWYWxpZEV0aGVyZXVtQWRkcmVzcyA9IChhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGFkZHJlc3MpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ2hhbGxlbmdlID0gKCk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgXG4gICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgXG4gICAgICAgICBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn07Il0sIm5hbWVzIjpbIldhbGxldE1hbmFnZXIiLCJpc01ldGFNYXNrQXZhaWxhYmxlIiwid2luZG93IiwiZXRoZXJldW0iLCJpc01ldGFNYXNrIiwiY29ubmVjdE1ldGFNYXNrIiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwiYWRkcmVzc2VzIiwicmVxdWVzdCIsIm1ldGhvZCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImFkZHJlc3MiLCJ0cmltIiwiY2xlYW5lZEFkZHJlc3MiLCJ0ZXN0IiwibG93ZXJjYXNlQWRkcmVzcyIsInRvTG93ZXJDYXNlIiwid2FsbGV0SW5mbyIsInB1YmxpY0tleSIsInVuZGVmaW5lZCIsInByb3ZpZGVyIiwiZXJyb3IiLCJtZXNzYWdlIiwic2lnbk1lc3NhZ2UiLCJzaWduYXR1cmUiLCJwYXJhbXMiLCJvbkFjY291bnRzQ2hhbmdlZCIsImNhbGxiYWNrIiwib24iLCJyZW1vdmVMaXN0ZW5lciIsIm9uQ2hhaW5DaGFuZ2VkIiwiZ2V0QXBpQmFzZVVybCIsIm5leHRQdWJsaWNVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInJlYWN0QXBwVXJsIiwiUkVBQ1RfQVBQX0FQSV9VUkwiLCJOT0RFX0VOViIsImRlZmF1bHRVcmwiLCJob3N0bmFtZSIsImxvY2F0aW9uIiwiaW5jbHVkZXMiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiQXV0aEFQSSIsImJhc2VVUkwiLCJnZXRBdXRoQ2hhbGxlbmdlIiwid2FsbGV0QWRkcmVzcyIsImZ1bGxVcmwiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGF0dXMiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJkYXRhIiwianNvbiIsInN1Y2Nlc3MiLCJjaGFsbGVuZ2UiLCJ0aW1lc3RhbXAiLCJub25jZSIsInZlcmlmeVNpZ25hdHVyZSIsImVycm9yRGF0YSIsImNhdGNoIiwic3RhdHVzVGV4dCIsInRva2VuIiwidXNlciIsImlkIiwiZGlzcGxheV9uYW1lIiwidXNlcm5hbWUiLCJhdmF0YXJfdXJsIiwiYmlvIiwidmVyaWZpY2F0aW9uX3N0YXR1cyIsInZlcmlmaWNhdGlvbkxldmVsIiwiY3JlYXRlZF9hdCIsImNyZWF0ZWRBdCIsIm9uYm9hcmRpbmdfY29tcGxldGVkIiwicHJvZmlsZUNvbXBsZXRpb24iLCJpc05ld1VzZXIiLCJhY2NvdW50VGllciIsImF1dGhNZXRob2QiLCJnZXRDdXJyZW50VXNlciIsImVtYWlsIiwidmVyaWZ5VG9rZW4iLCJ2YWxpZCIsIkF1dGhTdG9yYWdlIiwic2F2ZVRva2VuIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIlRPS0VOX0tFWSIsImdldFRva2VuIiwiZ2V0SXRlbSIsInJlbW92ZVRva2VuIiwicmVtb3ZlSXRlbSIsInNhdmVVc2VyIiwiVVNFUl9LRVkiLCJnZXRVc2VyIiwidXNlckRhdGEiLCJwYXJzZSIsInJlbW92ZVVzZXIiLCJjbGVhciIsImNyZWF0ZUF1dGhNZXNzYWdlIiwiaXNWYWxpZEV0aGVyZXVtQWRkcmVzcyIsImdlbmVyYXRlQ2hhbGxlbmdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiRGF0ZSIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

}]);