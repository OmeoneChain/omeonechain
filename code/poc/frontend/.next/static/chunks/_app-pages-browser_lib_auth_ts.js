"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_auth_ts"],{

/***/ "(app-pages-browser)/./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// shim for using process in browser\n\nvar process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;\nvar cachedClearTimeout;\nfunction defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while(len){\n        currentQueue = queue;\n        queue = [];\n        while(++queueIndex < len){\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nprocess.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for(var i = 1; i < arguments.length; i++){\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n_c = Item;\nItem.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nprocess.title = \"browser\";\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \"\"; // empty string to avoid regexp issues\nprocess.versions = {};\nfunction noop() {}\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\nprocess.listeners = function(name) {\n    return [];\n};\nprocess.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\nprocess.cwd = function() {\n    return \"/\";\n};\nprocess.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\nprocess.umask = function() {\n    return 0;\n};\nvar _c;\n$RefreshReg$(_c, \"Item\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0NBQW9DOztBQUNwQyxJQUFJQSxVQUFVQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQztBQUVoQywyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLCtFQUErRTtBQUMvRSw4REFBOEQ7QUFFOUQsSUFBSUM7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ0wsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBQ0EsU0FBU0M7SUFDTCxNQUFNLElBQUlELE1BQU07QUFDcEI7QUFDQztJQUNHLElBQUk7UUFDQSxJQUFJLE9BQU9FLGVBQWUsWUFBWTtZQUNsQ0wsbUJBQW1CSztRQUN2QixPQUFPO1lBQ0hMLG1CQUFtQkU7UUFDdkI7SUFDSixFQUFFLE9BQU9JLEdBQUc7UUFDUk4sbUJBQW1CRTtJQUN2QjtJQUNBLElBQUk7UUFDQSxJQUFJLE9BQU9LLGlCQUFpQixZQUFZO1lBQ3BDTixxQkFBcUJNO1FBQ3pCLE9BQU87WUFDSE4scUJBQXFCRztRQUN6QjtJQUNKLEVBQUUsT0FBT0UsR0FBRztRQUNSTCxxQkFBcUJHO0lBQ3pCO0FBQ0o7QUFDQSxTQUFTSSxXQUFXQyxHQUFHO0lBQ25CLElBQUlULHFCQUFxQkssWUFBWTtRQUNqQyx1Q0FBdUM7UUFDdkMsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNULHFCQUFxQkUsb0JBQW9CLENBQUNGLGdCQUFlLEtBQU1LLFlBQVk7UUFDNUVMLG1CQUFtQks7UUFDbkIsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLElBQUk7UUFDQSxzRUFBc0U7UUFDdEUsT0FBT1QsaUJBQWlCUyxLQUFLO0lBQ2pDLEVBQUUsT0FBTUgsR0FBRTtRQUNOLElBQUk7WUFDQSxrSEFBa0g7WUFDbEgsT0FBT04saUJBQWlCVSxJQUFJLENBQUMsTUFBTUQsS0FBSztRQUM1QyxFQUFFLE9BQU1ILEdB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QyxRQUFRLEdBQUcsQ0FBQztBQUVwQixTQUFTQyxRQUFRO0FBRWpCM0MsUUFBUTRDLEVBQUUsR0FBR0Q7QUFDYjNDLFFBQVE2QyxXQUFXLEdBQUdGO0FBQ3RCM0MsUUFBUThDLElBQUksR0FBR0g7QUFDZjNDLFFBQVErQyxHQUFHLEdBQUdKO0FBQ2QzQyxRQUFRZ0QsY0FBYyxHQUFHTDtBQUN6QjNDLFFBQVFpRCxrQkFBa0IsR0FBR047QUFDN0IzQyxRQUFRa0QsSUFBSSxHQUFHUDtBQUNmM0MsUUFBUW1ELGVBQWUsR0FBR1I7QUFDMUIzQyxRQUFRb0QsbUJBQW1CLEdBQUdUO0FBRTlCM0MsUUFBUXFELFNBQVMsR0FBRyxTQUFVQyxJQUFJO0lBQUksT0FBTyxFQUFFO0FBQUM7QUFFaER0RCxRQUFRdUQsT0FBTyxHQUFHLFNBQVVELElBQUk7SUFDNUIsTUFBTSxJQUFJaEQsTUFBTTtBQUNwQjtBQUVBTixRQUFRd0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBQ3ZDeEQsUUFBUXlELEtBQUssR0FBRyxTQUFVQyxHQUFHO0lBQ3pCLE1BQU0sSUFBSXBELE1BQU07QUFDcEI7QUFDQU4sUUFBUTJELEtBQUssR0FBRztJQUFhLE9BQU87QUFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzVjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAPI: function() { return /* binding */ AuthAPI; },\n/* harmony export */   AuthStorage: function() { return /* binding */ AuthStorage; },\n/* harmony export */   WalletManager: function() { return /* binding */ WalletManager; },\n/* harmony export */   createAuthMessage: function() { return /* binding */ createAuthMessage; },\n/* harmony export */   generateChallenge: function() { return /* binding */ generateChallenge; },\n/* harmony export */   isValidEthereumAddress: function() { return /* binding */ isValidEthereumAddress; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// code/poc/frontend/lib/auth.ts\n// FIXED VERSION: Corrected API base URL configuration to prevent double /api/ issue\n// Wallet detection and connection utilities\nclass WalletManager {\n    // Check if MetaMask is available\n    static isMetaMaskAvailable() {\n        return  true && typeof window.ethereum !== \"undefined\" && window.ethereum.isMetaMask;\n    }\n    // Connect to MetaMask\n    static async connectMetaMask() {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not found. Please install MetaMask browser extension.\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            // Request account access\n            const addresses = await ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            if (!addresses || addresses.length === 0) {\n                throw new Error(\"No accounts found. Please unlock MetaMask.\");\n            }\n            const address = addresses[0];\n            // Get the public key if available (optional)\n            let publicKey;\n            try {\n                publicKey = await ethereum.request({\n                    method: \"eth_getEncryptionPublicKey\",\n                    params: [\n                        address\n                    ]\n                });\n            } catch (error) {\n                console.log(\"Could not get public key:\", error);\n            }\n            return {\n                address: address.toLowerCase(),\n                publicKey,\n                provider: \"metamask\"\n            };\n        } catch (error) {\n            console.error(\"MetaMask connection error:\", error);\n            throw new Error(\"Failed to connect MetaMask: \".concat(error.message));\n        }\n    }\n    // Sign a message with wallet\n    static async signMessage(message, address) {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not available\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            const signature = await ethereum.request({\n                method: \"personal_sign\",\n                params: [\n                    message,\n                    address\n                ]\n            });\n            return signature;\n        } catch (error) {\n            console.error(\"Message signing error:\", error);\n            throw new Error(\"Failed to sign message: \".concat(error.message));\n        }\n    }\n    // Listen for account changes\n    static onAccountsChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"accountsChanged\", callback);\n        // Return cleanup function\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"accountsChanged\", callback);\n            }\n        };\n    }\n    // Listen for network changes\n    static onChainChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"chainChanged\", callback);\n        // Return cleanup function\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"chainChanged\", callback);\n            }\n        };\n    }\n}\n// FIXED: Corrected URL detection and API base configuration\nconst getApiBaseUrl = ()=>{\n    // Try environment variables in order of preference\n    const nextPublicUrl = \"https://redesigned-lamp-q74wgggqq9jjfxqjp-3001.app.github.dev\";\n    const reactAppUrl = process.env.REACT_APP_API_URL;\n    console.log(\"\\uD83D\\uDD27 lib/auth.ts Environment Check:\", {\n        NEXT_PUBLIC_API_URL: nextPublicUrl,\n        REACT_APP_API_URL: reactAppUrl,\n        NODE_ENV: \"development\",\n        window_location:  true ? window.location.href : 0\n    });\n    // FIXED: Use backend port 3001 (where your Express server runs) WITHOUT extra /api suffix\n    const defaultUrl = nextPublicUrl || reactAppUrl;\n    // If no env var is set, detect Codespaces URL or use localhost\n    if (!defaultUrl) {\n        if (true) {\n            const hostname = window.location.hostname;\n            if (hostname.includes(\"github.dev\") || hostname.includes(\"gitpod.io\")) {\n                // Extract Codespaces/Gitpod base and point to backend port\n                const baseUrl = \"\".concat(window.location.protocol, \"//\").concat(hostname.replace(\"-3000\", \"-3001\"));\n                return baseUrl; // FIXED: Return base URL without /api suffix\n            }\n        }\n        return \"http://localhost:3001\"; // FIXED: Backend runs on 3001 without /api suffix\n    }\n    // FIXED: Ensure URL does NOT have /api suffix (we'll add it in the API calls)\n    const baseUrl = defaultUrl.replace(/\\/api.*$/, \"\");\n    console.log(\"\\uD83D\\uDD17 lib/auth.ts using API base URL:\", baseUrl);\n    return baseUrl;\n};\n// Authentication API client\nclass AuthAPI {\n    static get baseURL() {\n        return getApiBaseUrl();\n    }\n    // FIXED: Generate authentication challenge with correct endpoint\n    static async getAuthChallenge(walletAddress) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/challenge\");\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Getting auth challenge from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Challenge response status:\", response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"❌ lib/auth.ts: Challenge failed:\", response.status, errorText);\n                throw new Error(\"Failed to get auth challenge: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(errorText));\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Challenge data received:\", data);\n            // FIXED: Handle backend response format\n            if (data.success) {\n                return {\n                    challenge: data.challenge,\n                    timestamp: data.timestamp,\n                    nonce: data.nonce\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response format from auth challenge endpoint\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Auth challenge error:\", error);\n            throw new Error(\"Failed to get auth challenge: \".concat(error.message));\n        }\n    }\n    // FIXED: Verify signature with correct endpoint\n    static async verifySignature(walletAddress, signature, challenge, timestamp, nonce) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/login\");\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verifying signature at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress,\n                    signature,\n                    challenge,\n                    timestamp,\n                    nonce\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verify response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: response.statusText\n                    }));\n                console.error(\"❌ lib/auth.ts: Verify failed:\", errorData);\n                throw new Error(\"Authentication failed: \".concat(errorData.error || response.statusText));\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Verify data received:\", data);\n            // FIXED: Handle backend response format\n            if (data.success && data.token && data.user) {\n                return {\n                    token: data.token,\n                    user: {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.pseudonym || \"User \".concat(data.user.walletAddress.slice(-4)),\n                        verification_status: \"basic\",\n                        created_at: new Date().toISOString()\n                    }\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response format from auth verify endpoint\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Signature verification error:\", error);\n            throw new Error(\"Authentication failed: \".concat(error.message));\n        }\n    }\n    // FIXED: Get current user info with correct endpoint\n    static async getCurrentUser(token) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/me\");\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Getting current user from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(token)\n                },\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to get user info: \".concat(response.statusText));\n            }\n            const data = await response.json();\n            // FIXED: Handle backend response format\n            if (data.success && data.user) {\n                return {\n                    id: data.user.id,\n                    address: data.user.walletAddress,\n                    display_name: data.user.pseudonym || \"User \".concat(data.user.walletAddress.slice(-4)),\n                    verification_status: \"basic\",\n                    created_at: data.user.created_at\n                };\n            } else {\n                throw new Error(data.error || \"Invalid user data received\");\n            }\n        } catch (error) {\n            console.error(\"Get current user error:\", error);\n            throw new Error(\"Failed to get user info: \".concat(error.message));\n        }\n    }\n    // FIXED: Verify JWT token with correct endpoint\n    static async verifyToken(token) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/verify\");\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Verifying token at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    token\n                })\n            });\n            if (!response.ok) {\n                return {\n                    valid: false\n                };\n            }\n            const data = await response.json();\n            if (data.success && data.valid) {\n                return {\n                    valid: true,\n                    user: data.user ? {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.pseudonym || \"User \".concat(data.user.walletAddress.slice(-4)),\n                        verification_status: \"basic\"\n                    } : undefined\n                };\n            } else {\n                return {\n                    valid: false\n                };\n            }\n        } catch (error) {\n            console.error(\"Token verification error:\", error);\n            return {\n                valid: false\n            };\n        }\n    }\n}\n// Local storage utilities\nclass AuthStorage {\n    static saveToken(token) {\n        if (true) {\n            localStorage.setItem(this.TOKEN_KEY, token);\n        }\n    }\n    static getToken() {\n        if (true) {\n            return localStorage.getItem(this.TOKEN_KEY);\n        }\n        return null;\n    }\n    static removeToken() {\n        if (true) {\n            localStorage.removeItem(this.TOKEN_KEY);\n        }\n    }\n    static saveUser(user) {\n        if (true) {\n            localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n        }\n    }\n    static getUser() {\n        if (true) {\n            const userData = localStorage.getItem(this.USER_KEY);\n            if (userData) {\n                try {\n                    return JSON.parse(userData);\n                } catch (error) {\n                    console.error(\"Failed to parse stored user data:\", error);\n                    this.removeUser();\n                }\n            }\n        }\n        return null;\n    }\n    static removeUser() {\n        if (true) {\n            localStorage.removeItem(this.USER_KEY);\n        }\n    }\n    static clear() {\n        this.removeToken();\n        this.removeUser();\n    }\n}\nAuthStorage.TOKEN_KEY = \"omeone_auth_token\";\nAuthStorage.USER_KEY = \"omeone_user\";\n// FIXED: Utility functions to match backend challenge format\nconst createAuthMessage = (challenge, walletAddress)=>{\n    // This should match the challenge message format from your backend auth routes\n    return challenge; // Backend already provides the complete formatted message\n};\nconst isValidEthereumAddress = (address)=>{\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n};\n// Generate a random challenge string (fallback - backend should handle this)\nconst generateChallenge = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNqQjtBQUNGO0FBdERhZCxZQUNJSSxZQUFZO0FBRGhCSixZQUVJVSxXQUFXO0FBc0Q1Qiw2REFBNkQ7QUFDdEQsTUFBTU0sb0JBQW9CLENBQUNwQyxXQUFtQmpCO0lBQ25ELCtFQUErRTtJQUMvRSxPQUFPaUIsV0FBVywwREFBMEQ7QUFDOUUsRUFBRTtBQUVLLE1BQU1xQyx5QkFBeUIsQ0FBQzFGO0lBQ3JDLE9BQU8sc0JBQXNCMkYsSUFBSSxDQUFDM0Y7QUFDcEMsRUFBRTtBQUVGLDZFQUE2RTtBQUN0RSxNQUFNNEYsb0JBQW9CO0lBQy9CLE9BQU9DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLE1BQ3hDSCxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRyxNQUN4QzdCLEtBQUs4QixHQUFHLEdBQUdGLFFBQVEsQ0FBQztBQUM3QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hdXRoLnRzP2JmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29kZS9wb2MvZnJvbnRlbmQvbGliL2F1dGgudHNcbi8vIEZJWEVEIFZFUlNJT046IENvcnJlY3RlZCBBUEkgYmFzZSBVUkwgY29uZmlndXJhdGlvbiB0byBwcmV2ZW50IGRvdWJsZSAvYXBpLyBpc3N1ZVxuXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LWhvdC10b2FzdCc7XG5cbi8vIFR5cGVzIGZvciBhdXRoZW50aWNhdGlvblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB1c2VybmFtZT86IHN0cmluZztcbiAgZGlzcGxheV9uYW1lPzogc3RyaW5nO1xuICBhdmF0YXJfdXJsPzogc3RyaW5nO1xuICB2ZXJpZmljYXRpb25fc3RhdHVzPzogJ2Jhc2ljJyB8ICd2ZXJpZmllZCcgfCAnZXhwZXJ0JztcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoU3RhdGUge1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgdXNlcjogVXNlciB8IG51bGw7XG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldEluZm8ge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHB1YmxpY0tleT86IHN0cmluZztcbiAgcHJvdmlkZXI6ICdtZXRhbWFzaycgfCAnd2FsbGV0Y29ubmVjdCcgfCAnY29pbmJhc2UnIHwgJ21hbnVhbCc7XG59XG5cbi8vIFdhbGxldCBkZXRlY3Rpb24gYW5kIGNvbm5lY3Rpb24gdXRpbGl0aWVzXG5leHBvcnQgY2xhc3MgV2FsbGV0TWFuYWdlciB7XG4gIC8vIENoZWNrIGlmIE1ldGFNYXNrIGlzIGF2YWlsYWJsZVxuICBzdGF0aWMgaXNNZXRhTWFza0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgXG4gICAgICAgICAgIHR5cGVvZiAod2luZG93IGFzIGFueSkuZXRoZXJldW0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bS5pc01ldGFNYXNrO1xuICB9XG5cbiAgLy8gQ29ubmVjdCB0byBNZXRhTWFza1xuICBzdGF0aWMgYXN5bmMgY29ubmVjdE1ldGFNYXNrKCk6IFByb21pc2U8V2FsbGV0SW5mbz4ge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbi4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgICBcbiAgICAgIC8vIFJlcXVlc3QgYWNjb3VudCBhY2Nlc3NcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYWRkcmVzc2VzIHx8IGFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZC4gUGxlYXNlIHVubG9jayBNZXRhTWFzay4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3Nlc1swXTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBwdWJsaWMga2V5IGlmIGF2YWlsYWJsZSAob3B0aW9uYWwpXG4gICAgICBsZXQgcHVibGljS2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBwdWJsaWNLZXkgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXG4gICAgICAgICAgcGFyYW1zOiBbYWRkcmVzc11cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGdldCBwdWJsaWMga2V5OicsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIHByb3ZpZGVyOiAnbWV0YW1hc2snXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01ldGFNYXNrIGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCBNZXRhTWFzazogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNpZ24gYSBtZXNzYWdlIHdpdGggd2FsbGV0XG4gIHN0YXRpYyBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmlzTWV0YU1hc2tBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV0aGVyZXVtID0gKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtO1xuICAgICAgXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAncGVyc29uYWxfc2lnbicsXG4gICAgICAgIHBhcmFtczogW21lc3NhZ2UsIGFkZHJlc3NdXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNZXNzYWdlIHNpZ25pbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBhY2NvdW50IGNoYW5nZXNcbiAgc3RhdGljIG9uQWNjb3VudHNDaGFuZ2VkKGNhbGxiYWNrOiAoYWRkcmVzc2VzOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBldGhlcmV1bSA9ICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bTtcbiAgICBldGhlcmV1bS5vbignYWNjb3VudHNDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgIFxuICAgIC8vIFJldHVybiBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChldGhlcmV1bSAmJiBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcignYWNjb3VudHNDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIG5ldHdvcmsgY2hhbmdlc1xuICBzdGF0aWMgb25DaGFpbkNoYW5nZWQoY2FsbGJhY2s6IChjaGFpbklkOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICBpZiAoIXRoaXMuaXNNZXRhTWFza0F2YWlsYWJsZSgpKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgZXRoZXJldW0ub24oJ2NoYWluQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gY2xlYW51cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZXRoZXJldW0gJiYgZXRoZXJldW0ucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgZXRoZXJldW0ucmVtb3ZlTGlzdGVuZXIoJ2NoYWluQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIEZJWEVEOiBDb3JyZWN0ZWQgVVJMIGRldGVjdGlvbiBhbmQgQVBJIGJhc2UgY29uZmlndXJhdGlvblxuY29uc3QgZ2V0QXBpQmFzZVVybCA9ICgpOiBzdHJpbmcgPT4ge1xuICAvLyBUcnkgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgY29uc3QgbmV4dFB1YmxpY1VybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gIGNvbnN0IHJlYWN0QXBwVXJsID0gcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0FQSV9VUkw7XG4gIFxuICBjb25zb2xlLmxvZygn8J+UpyBsaWIvYXV0aC50cyBFbnZpcm9ubWVudCBDaGVjazonLCB7XG4gICAgTkVYVF9QVUJMSUNfQVBJX1VSTDogbmV4dFB1YmxpY1VybCxcbiAgICBSRUFDVF9BUFBfQVBJX1VSTDogcmVhY3RBcHBVcmwsXG4gICAgTk9ERV9FTlY6IHByb2Nlc3MuZW52Lk5PREVfRU5WLFxuICAgIHdpbmRvd19sb2NhdGlvbjogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICdTU1InXG4gIH0pO1xuXG4gIC8vIEZJWEVEOiBVc2UgYmFja2VuZCBwb3J0IDMwMDEgKHdoZXJlIHlvdXIgRXhwcmVzcyBzZXJ2ZXIgcnVucykgV0lUSE9VVCBleHRyYSAvYXBpIHN1ZmZpeFxuICBjb25zdCBkZWZhdWx0VXJsID0gbmV4dFB1YmxpY1VybCB8fCByZWFjdEFwcFVybDtcbiAgXG4gIC8vIElmIG5vIGVudiB2YXIgaXMgc2V0LCBkZXRlY3QgQ29kZXNwYWNlcyBVUkwgb3IgdXNlIGxvY2FsaG9zdFxuICBpZiAoIWRlZmF1bHRVcmwpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCdnaXRodWIuZGV2JykgfHwgaG9zdG5hbWUuaW5jbHVkZXMoJ2dpdHBvZC5pbycpKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgQ29kZXNwYWNlcy9HaXRwb2QgYmFzZSBhbmQgcG9pbnQgdG8gYmFja2VuZCBwb3J0XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke2hvc3RuYW1lLnJlcGxhY2UoJy0zMDAwJywgJy0zMDAxJyl9YDtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7IC8vIEZJWEVEOiBSZXR1cm4gYmFzZSBVUkwgd2l0aG91dCAvYXBpIHN1ZmZpeFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7IC8vIEZJWEVEOiBCYWNrZW5kIHJ1bnMgb24gMzAwMSB3aXRob3V0IC9hcGkgc3VmZml4XG4gIH1cbiAgXG4gIC8vIEZJWEVEOiBFbnN1cmUgVVJMIGRvZXMgTk9UIGhhdmUgL2FwaSBzdWZmaXggKHdlJ2xsIGFkZCBpdCBpbiB0aGUgQVBJIGNhbGxzKVxuICBjb25zdCBiYXNlVXJsID0gZGVmYXVsdFVybC5yZXBsYWNlKC9cXC9hcGkuKiQvLCAnJyk7XG4gIGNvbnNvbGUubG9nKCfwn5SXIGxpYi9hdXRoLnRzIHVzaW5nIEFQSSBiYXNlIFVSTDonLCBiYXNlVXJsKTtcbiAgXG4gIHJldHVybiBiYXNlVXJsO1xufTtcblxuLy8gQXV0aGVudGljYXRpb24gQVBJIGNsaWVudFxuZXhwb3J0IGNsYXNzIEF1dGhBUEkge1xuICBwcml2YXRlIHN0YXRpYyBnZXQgYmFzZVVSTCgpIHtcbiAgICByZXR1cm4gZ2V0QXBpQmFzZVVybCgpO1xuICB9XG5cbiAgLy8gRklYRUQ6IEdlbmVyYXRlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSB3aXRoIGNvcnJlY3QgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIGdldEF1dGhDaGFsbGVuZ2Uod2FsbGV0QWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx7IGNoYWxsZW5nZTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlcjsgbm9uY2U6IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxVcmwgPSBgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL2NoYWxsZW5nZWA7XG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogR2V0dGluZyBhdXRoIGNoYWxsZW5nZSBmcm9tOicsIGZ1bGxVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLCAvLyBGSVhFRDogSW5jbHVkZSBjcmVkZW50aWFscyBmb3IgQ09SU1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHdhbGxldEFkZHJlc3MgfSksIC8vIEZJWEVEOiBNYXRjaCBiYWNrZW5kIHBhcmFtZXRlciBuYW1lXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IENoYWxsZW5nZSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogQ2hhbGxlbmdlIGZhaWxlZDonLCByZXNwb25zZS5zdGF0dXMsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBhdXRoIGNoYWxsZW5nZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgbGliL2F1dGgudHM6IENoYWxsZW5nZSBkYXRhIHJlY2VpdmVkOicsIGRhdGEpO1xuICAgICAgXG4gICAgICAvLyBGSVhFRDogSGFuZGxlIGJhY2tlbmQgcmVzcG9uc2UgZm9ybWF0XG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbGxlbmdlOiBkYXRhLmNoYWxsZW5nZSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wLFxuICAgICAgICAgIG5vbmNlOiBkYXRhLm5vbmNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBhdXRoIGNoYWxsZW5nZSBlbmRwb2ludCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogQXV0aCBjaGFsbGVuZ2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGF1dGggY2hhbGxlbmdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRklYRUQ6IFZlcmlmeSBzaWduYXR1cmUgd2l0aCBjb3JyZWN0IGVuZHBvaW50XG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlTaWduYXR1cmUoXG4gICAgd2FsbGV0QWRkcmVzczogc3RyaW5nLCBcbiAgICBzaWduYXR1cmU6IHN0cmluZywgXG4gICAgY2hhbGxlbmdlOiBzdHJpbmcsXG4gICAgdGltZXN0YW1wPzogbnVtYmVyLFxuICAgIG5vbmNlPzogc3RyaW5nXG4gICk6IFByb21pc2U8eyB0b2tlbjogc3RyaW5nOyB1c2VyOiBVc2VyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvbG9naW5gO1xuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IFZlcmlmeWluZyBzaWduYXR1cmUgYXQ6JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsIC8vIEZJWEVEOiBJbmNsdWRlIGNyZWRlbnRpYWxzIGZvciBDT1JTXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgd2FsbGV0QWRkcmVzcywgXG4gICAgICAgICAgc2lnbmF0dXJlLCBcbiAgICAgICAgICBjaGFsbGVuZ2UsXG4gICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgIG5vbmNlXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIGxpYi9hdXRoLnRzOiBWZXJpZnkgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGVycm9yOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBWZXJpZnkgZmFpbGVkOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YS5lcnJvciB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBsaWIvYXV0aC50czogVmVyaWZ5IGRhdGEgcmVjZWl2ZWQ6JywgZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEZJWEVEOiBIYW5kbGUgYmFja2VuZCByZXNwb25zZSBmb3JtYXRcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS50b2tlbiAmJiBkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbjogZGF0YS50b2tlbixcbiAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxuICAgICAgICAgICAgYWRkcmVzczogZGF0YS51c2VyLndhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5wc2V1ZG9ueW0gfHwgYFVzZXIgJHtkYXRhLnVzZXIud2FsbGV0QWRkcmVzcy5zbGljZSgtNCl9YCxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbl9zdGF0dXM6ICdiYXNpYycsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBhdXRoIHZlcmlmeSBlbmRwb2ludCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWEVEOiBHZXQgY3VycmVudCB1c2VyIGluZm8gd2l0aCBjb3JyZWN0IGVuZHBvaW50XG4gIHN0YXRpYyBhc3luYyBnZXRDdXJyZW50VXNlcih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxVcmwgPSBgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL21lYDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIGxpYi9hdXRoLnRzOiBHZXR0aW5nIGN1cnJlbnQgdXNlciBmcm9tOicsIGZ1bGxVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdXNlciBpbmZvOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIC8vIEZJWEVEOiBIYW5kbGUgYmFja2VuZCByZXNwb25zZSBmb3JtYXRcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICBhZGRyZXNzOiBkYXRhLnVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5wc2V1ZG9ueW0gfHwgYFVzZXIgJHtkYXRhLnVzZXIud2FsbGV0QWRkcmVzcy5zbGljZSgtNCl9YCxcbiAgICAgICAgICB2ZXJpZmljYXRpb25fc3RhdHVzOiAnYmFzaWMnLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGRhdGEudXNlci5jcmVhdGVkX2F0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCB1c2VyIGRhdGEgcmVjZWl2ZWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdHZXQgY3VycmVudCB1c2VyIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB1c2VyIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBGSVhFRDogVmVyaWZ5IEpXVCB0b2tlbiB3aXRoIGNvcnJlY3QgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIHZlcmlmeVRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW47IHVzZXI/OiBVc2VyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvdmVyaWZ5YDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIGxpYi9hdXRoLnRzOiBWZXJpZnlpbmcgdG9rZW4gYXQ6JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4gfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyID8ge1xuICAgICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEudXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBkYXRhLnVzZXIucHNldWRvbnltIHx8IGBVc2VyICR7ZGF0YS51c2VyLndhbGxldEFkZHJlc3Muc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25fc3RhdHVzOiAnYmFzaWMnLFxuICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTG9jYWwgc3RvcmFnZSB1dGlsaXRpZXNcbmV4cG9ydCBjbGFzcyBBdXRoU3RvcmFnZSB7XG4gIHByaXZhdGUgc3RhdGljIFRPS0VOX0tFWSA9ICdvbWVvbmVfYXV0aF90b2tlbic7XG4gIHByaXZhdGUgc3RhdGljIFVTRVJfS0VZID0gJ29tZW9uZV91c2VyJztcblxuICBzdGF0aWMgc2F2ZVRva2VuKHRva2VuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuVE9LRU5fS0VZLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlVG9rZW4oKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRPS0VOX0tFWSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNhdmVVc2VyKHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuVVNFUl9LRVksIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0VXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVVNFUl9LRVkpO1xuICAgICAgaWYgKHVzZXJEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodXNlckRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdG9yZWQgdXNlciBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVVc2VyKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5VU0VSX0tFWSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMucmVtb3ZlVG9rZW4oKTtcbiAgICB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgfVxufVxuXG4vLyBGSVhFRDogVXRpbGl0eSBmdW5jdGlvbnMgdG8gbWF0Y2ggYmFja2VuZCBjaGFsbGVuZ2UgZm9ybWF0XG5leHBvcnQgY29uc3QgY3JlYXRlQXV0aE1lc3NhZ2UgPSAoY2hhbGxlbmdlOiBzdHJpbmcsIHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBjaGFsbGVuZ2UgbWVzc2FnZSBmb3JtYXQgZnJvbSB5b3VyIGJhY2tlbmQgYXV0aCByb3V0ZXNcbiAgcmV0dXJuIGNoYWxsZW5nZTsgLy8gQmFja2VuZCBhbHJlYWR5IHByb3ZpZGVzIHRoZSBjb21wbGV0ZSBmb3JtYXR0ZWQgbWVzc2FnZVxufTtcblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRFdGhlcmV1bUFkZHJlc3MgPSAoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgcmFuZG9tIGNoYWxsZW5nZSBzdHJpbmcgKGZhbGxiYWNrIC0gYmFja2VuZCBzaG91bGQgaGFuZGxlIHRoaXMpXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVDaGFsbGVuZ2UgPSAoKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBcbiAgICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBcbiAgICAgICAgIERhdGUubm93KCkudG9TdHJpbmcoMzYpO1xufTsiXSwibmFtZXMiOlsiV2FsbGV0TWFuYWdlciIsImlzTWV0YU1hc2tBdmFpbGFibGUiLCJ3aW5kb3ciLCJldGhlcmV1bSIsImlzTWV0YU1hc2siLCJjb25uZWN0TWV0YU1hc2siLCJFcnJvciIsImFkZHJlc3NlcyIsInJlcXVlc3QiLCJtZXRob2QiLCJsZW5ndGgiLCJhZGRyZXNzIiwicHVibGljS2V5IiwicGFyYW1zIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwidG9Mb3dlckNhc2UiLCJwcm92aWRlciIsIm1lc3NhZ2UiLCJzaWduTWVzc2FnZSIsInNpZ25hdHVyZSIsIm9uQWNjb3VudHNDaGFuZ2VkIiwiY2FsbGJhY2siLCJvbiIsInJlbW92ZUxpc3RlbmVyIiwib25DaGFpbkNoYW5nZWQiLCJnZXRBcGlCYXNlVXJsIiwibmV4dFB1YmxpY1VybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwicmVhY3RBcHBVcmwiLCJSRUFDVF9BUFBfQVBJX1VSTCIsIk5PREVfRU5WIiwid2luZG93X2xvY2F0aW9uIiwibG9jYXRpb24iLCJocmVmIiwiZGVmYXVsdFVybCIsImhvc3RuYW1lIiwiaW5jbHVkZXMiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiQXV0aEFQSSIsImJhc2VVUkwiLCJnZXRBdXRoQ2hhbGxlbmdlIiwid2FsbGV0QWRkcmVzcyIsImZ1bGxVcmwiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGF0dXMiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwiY2hhbGxlbmdlIiwidGltZXN0YW1wIiwibm9uY2UiLCJ2ZXJpZnlTaWduYXR1cmUiLCJlcnJvckRhdGEiLCJjYXRjaCIsInRva2VuIiwidXNlciIsImlkIiwiZGlzcGxheV9uYW1lIiwicHNldWRvbnltIiwic2xpY2UiLCJ2ZXJpZmljYXRpb25fc3RhdHVzIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImdldEN1cnJlbnRVc2VyIiwidmVyaWZ5VG9rZW4iLCJ2YWxpZCIsInVuZGVmaW5lZCIsIkF1dGhTdG9yYWdlIiwic2F2ZVRva2VuIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIlRPS0VOX0tFWSIsImdldFRva2VuIiwiZ2V0SXRlbSIsInJlbW92ZVRva2VuIiwicmVtb3ZlSXRlbSIsInNhdmVVc2VyIiwiVVNFUl9LRVkiLCJnZXRVc2VyIiwidXNlckRhdGEiLCJwYXJzZSIsInJlbW92ZVVzZXIiLCJjbGVhciIsImNyZWF0ZUF1dGhNZXNzYWdlIiwiaXNWYWxpZEV0aGVyZXVtQWRkcmVzcyIsInRlc3QiLCJnZW5lcmF0ZUNoYWxsZW5nZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

}]);