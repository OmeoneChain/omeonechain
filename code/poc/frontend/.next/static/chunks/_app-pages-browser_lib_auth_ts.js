"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_auth_ts"],{

/***/ "(app-pages-browser)/./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// shim for using process in browser\n\nvar process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;\nvar cachedClearTimeout;\nfunction defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while(len){\n        currentQueue = queue;\n        queue = [];\n        while(++queueIndex < len){\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nprocess.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for(var i = 1; i < arguments.length; i++){\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n_c = Item;\nItem.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nprocess.title = \"browser\";\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \"\"; // empty string to avoid regexp issues\nprocess.versions = {};\nfunction noop() {}\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\nprocess.listeners = function(name) {\n    return [];\n};\nprocess.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\nprocess.cwd = function() {\n    return \"/\";\n};\nprocess.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\nprocess.umask = function() {\n    return 0;\n};\nvar _c;\n$RefreshReg$(_c, \"Item\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0NBQW9DOztBQUNwQyxJQUFJQSxVQUFVQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQztBQUVoQywyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLCtFQUErRTtBQUMvRSw4REFBOEQ7QUFFOUQsSUFBSUM7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ0wsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBQ0EsU0FBU0M7SUFDTCxNQUFNLElBQUlELE1BQU07QUFDcEI7QUFDQztJQUNHLElBQUk7UUFDQSxJQUFJLE9BQU9FLGVBQWUsWUFBWTtZQUNsQ0wsbUJBQW1CSztRQUN2QixPQUFPO1lBQ0hMLG1CQUFtQkU7UUFDdkI7SUFDSixFQUFFLE9BQU9JLEdBQUc7UUFDUk4sbUJBQW1CRTtJQUN2QjtJQUNBLElBQUk7UUFDQSxJQUFJLE9BQU9LLGlCQUFpQixZQUFZO1lBQ3BDTixxQkFBcUJNO1FBQ3pCLE9BQU87WUFDSE4scUJBQXFCRztRQUN6QjtJQUNKLEVBQUUsT0FBT0UsR0FBRztRQUNSTCxxQkFBcUJHO0lBQ3pCO0FBQ0o7QUFDQSxTQUFTSSxXQUFXQyxHQUFHO0lBQ25CLElBQUlULHFCQUFxQkssWUFBWTtRQUNqQyx1Q0FBdUM7UUFDdkMsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNULHFCQUFxQkUsb0JBQW9CLENBQUNGLGdCQUFlLEtBQU1LLFlBQVk7UUFDNUVMLG1CQUFtQks7UUFDbkIsT0FBT0EsV0FBV0ksS0FBSztJQUMzQjtJQUNBLElBQUk7UUFDQSxzRUFBc0U7UUFDdEUsT0FBT1QsaUJBQWlCUyxLQUFLO0lBQ2pDLEVBQUUsT0FBTUgsR0FBRTtRQUNOLElBQUk7WUFDQSxrSEFBa0g7WUFDbEgsT0FBT04saUJBQWlCVSxJQUFJLENBQUMsTUFBTUQsS0FBSztRQUM1QyxFQUFFLE9BQU1ILEdB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QyxRQUFRLEdBQUcsQ0FBQztBQUVwQixTQUFTQyxRQUFRO0FBRWpCM0MsUUFBUTRDLEVBQUUsR0FBR0Q7QUFDYjNDLFFBQVE2QyxXQUFXLEdBQUdGO0FBQ3RCM0MsUUFBUThDLElBQUksR0FBR0g7QUFDZjNDLFFBQVErQyxHQUFHLEdBQUdKO0FBQ2QzQyxRQUFRZ0QsY0FBYyxHQUFHTDtBQUN6QjNDLFFBQVFpRCxrQkFBa0IsR0FBR047QUFDN0IzQyxRQUFRa0QsSUFBSSxHQUFHUDtBQUNmM0MsUUFBUW1ELGVBQWUsR0FBR1I7QUFDMUIzQyxRQUFRb0QsbUJBQW1CLEdBQUdUO0FBRTlCM0MsUUFBUXFELFNBQVMsR0FBRyxTQUFVQyxJQUFJO0lBQUksT0FBTyxFQUFFO0FBQUM7QUFFaER0RCxRQUFRdUQsT0FBTyxHQUFHLFNBQVVELElBQUk7SUFDNUIsTUFBTSxJQUFJaEQsTUFBTTtBQUNwQjtBQUVBTixRQUFRd0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBQ3ZDeEQsUUFBUXlELEtBQUssR0FBRyxTQUFVQyxHQUFHO0lBQ3pCLE1BQU0sSUFBSXBELE1BQU07QUFDcEI7QUFDQU4sUUFBUTJELEtBQUssR0FBRztJQUFhLE9BQU87QUFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzVjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAPI: function() { return /* binding */ AuthAPI; },\n/* harmony export */   AuthStorage: function() { return /* binding */ AuthStorage; },\n/* harmony export */   WalletManager: function() { return /* binding */ WalletManager; },\n/* harmony export */   createAuthMessage: function() { return /* binding */ createAuthMessage; },\n/* harmony export */   generateChallenge: function() { return /* binding */ generateChallenge; },\n/* harmony export */   isValidEthereumAddress: function() { return /* binding */ isValidEthereumAddress; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// code/poc/frontend/lib/auth.ts\n// FIXED VERSION: Uses two-tier authentication endpoints\n// Wallet detection and connection utilities\nclass WalletManager {\n    // Check if MetaMask is available\n    static isMetaMaskAvailable() {\n        return  true && typeof window.ethereum !== \"undefined\" && window.ethereum.isMetaMask;\n    }\n    // Connect to MetaMask\n    static async connectMetaMask() {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not found. Please install MetaMask browser extension.\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            console.log(\"\\uD83D\\uDD0C WalletManager: Starting MetaMask connection...\");\n            const addresses = await ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            console.log(\"\\uD83D\\uDD0C WalletManager: Received addresses:\", addresses);\n            if (!addresses || !Array.isArray(addresses) || addresses.length === 0) {\n                throw new Error(\"No accounts found. Please unlock MetaMask.\");\n            }\n            const address = addresses[0];\n            if (!address || typeof address !== \"string\" || address.trim() === \"\") {\n                throw new Error(\"Invalid address received from MetaMask.\");\n            }\n            const cleanedAddress = address.trim();\n            if (!/^0x[a-fA-F0-9]{40}$/.test(cleanedAddress)) {\n                throw new Error(\"Invalid Ethereum address format.\");\n            }\n            const lowercaseAddress = cleanedAddress.toLowerCase();\n            const walletInfo = {\n                address: lowercaseAddress,\n                publicKey: undefined,\n                provider: \"metamask\"\n            };\n            return walletInfo;\n        } catch (error) {\n            console.error(\"❌ WalletManager: Connection error:\", error);\n            throw new Error(\"Failed to connect MetaMask: \".concat(error.message));\n        }\n    }\n    // Sign a message with wallet\n    static async signMessage(message, address) {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not available\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            console.log(\"✍️ WalletManager: Signing message...\");\n            const signature = await ethereum.request({\n                method: \"personal_sign\",\n                params: [\n                    message,\n                    address\n                ]\n            });\n            console.log(\"✅ WalletManager: Signature received\");\n            return signature;\n        } catch (error) {\n            console.error(\"❌ WalletManager: Message signing error:\", error);\n            throw new Error(\"Failed to sign message: \".concat(error.message));\n        }\n    }\n    // Listen for account changes\n    static onAccountsChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"accountsChanged\", callback);\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"accountsChanged\", callback);\n            }\n        };\n    }\n    // Listen for network changes\n    static onChainChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"chainChanged\", callback);\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"chainChanged\", callback);\n            }\n        };\n    }\n}\n// API base URL configuration\nconst getApiBaseUrl = ()=>{\n    const nextPublicUrl = \"https://redesigned-lamp-q74wgggqq9jjfxqjp-3001.app.github.dev/api\";\n    const reactAppUrl = process.env.REACT_APP_API_URL;\n    console.log(\"\\uD83D\\uDD27 lib/auth.ts Environment Check:\", {\n        NEXT_PUBLIC_API_URL: nextPublicUrl,\n        REACT_APP_API_URL: reactAppUrl,\n        NODE_ENV: \"development\"\n    });\n    const defaultUrl = nextPublicUrl || reactAppUrl;\n    if (!defaultUrl) {\n        if (true) {\n            const hostname = window.location.hostname;\n            if (hostname.includes(\"github.dev\") || hostname.includes(\"gitpod.io\")) {\n                const baseUrl = \"\".concat(window.location.protocol, \"//\").concat(hostname.replace(\"-3000\", \"-3001\"));\n                console.log(\"\\uD83D\\uDD17 lib/auth.ts: Detected Codespaces/Gitpod, using:\", baseUrl);\n                return baseUrl;\n            }\n        }\n        console.log(\"\\uD83D\\uDD17 lib/auth.ts: Using localhost:3001\");\n        return \"http://localhost:3001\";\n    }\n    const baseUrl = defaultUrl.replace(/\\/api.*$/, \"\");\n    console.log(\"\\uD83D\\uDD17 lib/auth.ts using API base URL:\", baseUrl);\n    return baseUrl;\n};\n// Authentication API client\nclass AuthAPI {\n    static get baseURL() {\n        return getApiBaseUrl();\n    }\n    // ✅ FIXED: Generate authentication challenge using two-tier endpoint\n    static async getAuthChallenge(walletAddress) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/wallet/challenge\"); // ✅ Changed from /auth/challenge\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Getting auth challenge from:\", fullUrl);\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Wallet address:\", walletAddress);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Challenge response status:\", response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"❌ lib/auth.ts: Challenge failed:\", response.status, errorText);\n                throw new Error(\"Failed to get auth challenge: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Challenge data received\");\n            if (data.success) {\n                return {\n                    challenge: data.challenge,\n                    timestamp: data.timestamp,\n                    nonce: data.nonce\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response from auth challenge\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Auth challenge error:\", error);\n            throw error;\n        }\n    }\n    // ✅ FIXED: Verify signature using two-tier endpoint\n    static async verifySignature(walletAddress, signature, challenge, timestamp, nonce) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/wallet/verify\"); // ✅ Changed from /auth/login\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verifying signature at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress,\n                    signature,\n                    challenge,\n                    timestamp,\n                    nonce\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verify response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: response.statusText\n                    }));\n                console.error(\"❌ lib/auth.ts: Verify failed:\", errorData);\n                throw new Error(\"Authentication failed: \".concat(errorData.error || response.statusText));\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Verify data received:\", data);\n            // ✅ FIXED: Handle two-tier response format with all fields\n            if (data.success && data.token && data.user) {\n                return {\n                    token: data.token,\n                    user: {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.display_name,\n                        username: data.user.username,\n                        avatar_url: data.user.avatar_url,\n                        bio: data.user.bio,\n                        verification_status: data.user.verificationLevel || \"basic\",\n                        created_at: data.user.createdAt,\n                        // ✅ Two-tier fields\n                        onboarding_completed: data.user.onboarding_completed,\n                        profileCompletion: data.user.profileCompletion,\n                        isNewUser: data.isNewUser,\n                        accountTier: data.user.accountTier,\n                        authMethod: data.user.authMethod\n                    }\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response from authentication\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Signature verification error:\", error);\n            throw error;\n        }\n    }\n    // Get current user info\n    static async getCurrentUser(token) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/me\");\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Getting current user from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(token)\n                },\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to get user info: \".concat(response.statusText));\n            }\n            const data = await response.json();\n            if (data.success && data.user) {\n                return {\n                    id: data.user.id,\n                    address: data.user.walletAddress,\n                    email: data.user.email,\n                    display_name: data.user.display_name,\n                    username: data.user.username,\n                    avatar_url: data.user.avatar_url,\n                    verification_status: \"basic\",\n                    created_at: data.user.created_at,\n                    // Two-tier fields\n                    onboarding_completed: data.user.onboarding_completed,\n                    profileCompletion: data.user.profileCompletion,\n                    accountTier: data.user.accountTier,\n                    authMethod: data.user.authMethod\n                };\n            } else {\n                throw new Error(data.error || \"Invalid user data received\");\n            }\n        } catch (error) {\n            console.error(\"Get current user error:\", error);\n            throw error;\n        }\n    }\n    // Email sign-up (two-tier endpoint)\n    static async emailSignup(email, password, displayName) {\n        try {\n            console.log(\"\\uD83D\\uDCE7 AuthAPI: Email sign-up request:\", email);\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/email/register\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password,\n                    display_name: displayName\n                })\n            });\n            console.log(\"\\uD83D\\uDCE7 AuthAPI: Sign-up response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.error || \"Sign-up failed: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"✅ AuthAPI: Email sign-up successful\");\n            return {\n                token: data.token,\n                user: {\n                    id: data.user.id,\n                    email: data.user.email,\n                    username: data.user.username,\n                    display_name: data.user.display_name,\n                    accountTier: data.user.accountTier,\n                    authMethod: data.user.authMethod,\n                    profileCompletion: data.user.profileCompletion,\n                    onboarding_completed: data.user.onboarding_completed\n                },\n                isNewUser: data.isNewUser\n            };\n        } catch (error) {\n            console.error(\"❌ AuthAPI: Email sign-up error:\", error);\n            throw error;\n        }\n    }\n    // Email login (two-tier endpoint)\n    static async emailLogin(email, password) {\n        try {\n            console.log(\"\\uD83D\\uDCE7 AuthAPI: Email login request:\", email);\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/auth/email/login\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                })\n            });\n            console.log(\"\\uD83D\\uDCE7 AuthAPI: Login response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.error || \"Login failed: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"✅ AuthAPI: Email login successful\");\n            return {\n                token: data.token,\n                user: {\n                    id: data.user.id,\n                    email: data.user.email,\n                    username: data.user.username,\n                    display_name: data.user.display_name,\n                    accountTier: data.user.accountTier,\n                    authMethod: data.user.authMethod,\n                    profileCompletion: data.user.profileCompletion,\n                    onboarding_completed: data.user.onboarding_completed\n                },\n                isNewUser: data.isNewUser\n            };\n        } catch (error) {\n            console.error(\"❌ AuthAPI: Email login error:\", error);\n            throw error;\n        }\n    }\n    // Verify JWT token\n    static async verifyToken(token) {\n        try {\n            const fullUrl = \"\".concat(this.baseURL, \"/api/auth/verify\");\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Verifying token at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    token\n                })\n            });\n            if (!response.ok) {\n                return {\n                    valid: false\n                };\n            }\n            const data = await response.json();\n            if (data.success && data.valid) {\n                return {\n                    valid: true,\n                    user: data.user ? {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        email: data.user.email,\n                        display_name: data.user.display_name,\n                        username: data.user.username,\n                        verification_status: \"basic\",\n                        accountTier: data.user.accountTier,\n                        authMethod: data.user.authMethod\n                    } : undefined\n                };\n            } else {\n                return {\n                    valid: false\n                };\n            }\n        } catch (error) {\n            console.error(\"Token verification error:\", error);\n            return {\n                valid: false\n            };\n        }\n    }\n}\n// Local storage utilities\nclass AuthStorage {\n    static saveToken(token) {\n        if (true) {\n            localStorage.setItem(this.TOKEN_KEY, token);\n        }\n    }\n    static getToken() {\n        if (true) {\n            return localStorage.getItem(this.TOKEN_KEY);\n        }\n        return null;\n    }\n    static removeToken() {\n        if (true) {\n            localStorage.removeItem(this.TOKEN_KEY);\n        }\n    }\n    static saveUser(user) {\n        if (true) {\n            localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n        }\n    }\n    static getUser() {\n        if (true) {\n            const userData = localStorage.getItem(this.USER_KEY);\n            if (userData) {\n                try {\n                    return JSON.parse(userData);\n                } catch (error) {\n                    console.error(\"Failed to parse stored user data:\", error);\n                    this.removeUser();\n                }\n            }\n        }\n        return null;\n    }\n    static removeUser() {\n        if (true) {\n            localStorage.removeItem(this.USER_KEY);\n        }\n    }\n    static clear() {\n        this.removeToken();\n        this.removeUser();\n    }\n}\nAuthStorage.TOKEN_KEY = \"omeone_auth_token\";\nAuthStorage.USER_KEY = \"omeone_user\";\n// Utility functions\nconst createAuthMessage = (challenge, walletAddress)=>{\n    return challenge;\n};\nconst isValidEthereumAddress = (address)=>{\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n};\nconst generateChallenge = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTWdELHlCQUF5QixDQUFDdEc7SUFDckMsT0FBTyxzQkFBc0JHLElBQUksQ0FBQ0g7QUFDcEMsRUFBRTtBQUVLLE1BQU11RyxvQkFBb0I7SUFDL0IsT0FBT0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsTUFDeENILEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLE1BQ3hDQyxLQUFLQyxHQUFHLEdBQUdILFFBQVEsQ0FBQztBQUM3QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hdXRoLnRzP2JmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29kZS9wb2MvZnJvbnRlbmQvbGliL2F1dGgudHNcbi8vIEZJWEVEIFZFUlNJT046IFVzZXMgdHdvLXRpZXIgYXV0aGVudGljYXRpb24gZW5kcG9pbnRzXG5cbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtaG90LXRvYXN0JztcblxuLy8gVHlwZXMgZm9yIGF1dGhlbnRpY2F0aW9uXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nO1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgdXNlcm5hbWU/OiBzdHJpbmc7XG4gIGRpc3BsYXlfbmFtZT86IHN0cmluZztcbiAgYXZhdGFyX3VybD86IHN0cmluZztcbiAgdmVyaWZpY2F0aW9uX3N0YXR1cz86ICdiYXNpYycgfCAndmVyaWZpZWQnIHwgJ2V4cGVydCc7XG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmc7XG4gIC8vIFR3by10aWVyIGZpZWxkc1xuICBvbmJvYXJkaW5nX2NvbXBsZXRlZD86IGJvb2xlYW47XG4gIHByb2ZpbGVDb21wbGV0aW9uPzogbnVtYmVyO1xuICBpc05ld1VzZXI/OiBib29sZWFuO1xuICBhY2NvdW50VGllcj86IHN0cmluZztcbiAgYXV0aE1ldGhvZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoU3RhdGUge1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgdXNlcjogVXNlciB8IG51bGw7XG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldEluZm8ge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHB1YmxpY0tleT86IHN0cmluZztcbiAgcHJvdmlkZXI6ICdtZXRhbWFzaycgfCAnd2FsbGV0Y29ubmVjdCcgfCAnY29pbmJhc2UnIHwgJ21hbnVhbCc7XG59XG5cbi8vIFdhbGxldCBkZXRlY3Rpb24gYW5kIGNvbm5lY3Rpb24gdXRpbGl0aWVzXG5leHBvcnQgY2xhc3MgV2FsbGV0TWFuYWdlciB7XG4gIC8vIENoZWNrIGlmIE1ldGFNYXNrIGlzIGF2YWlsYWJsZVxuICBzdGF0aWMgaXNNZXRhTWFza0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgXG4gICAgICAgICAgIHR5cGVvZiAod2luZG93IGFzIGFueSkuZXRoZXJldW0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bS5pc01ldGFNYXNrO1xuICB9XG5cbiAgLy8gQ29ubmVjdCB0byBNZXRhTWFza1xuICBzdGF0aWMgYXN5bmMgY29ubmVjdE1ldGFNYXNrKCk6IFByb21pc2U8V2FsbGV0SW5mbz4ge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbi4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SMIFdhbGxldE1hbmFnZXI6IFN0YXJ0aW5nIE1ldGFNYXNrIGNvbm5lY3Rpb24uLi4nKTtcbiAgICAgIFxuICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflIwgV2FsbGV0TWFuYWdlcjogUmVjZWl2ZWQgYWRkcmVzc2VzOicsIGFkZHJlc3Nlcyk7XG5cbiAgICAgIGlmICghYWRkcmVzc2VzIHx8ICFBcnJheS5pc0FycmF5KGFkZHJlc3NlcykgfHwgYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIGZvdW5kLiBQbGVhc2UgdW5sb2NrIE1ldGFNYXNrLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc2VzWzBdO1xuICAgICAgXG4gICAgICBpZiAoIWFkZHJlc3MgfHwgdHlwZW9mIGFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IGFkZHJlc3MudHJpbSgpID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyByZWNlaXZlZCBmcm9tIE1ldGFNYXNrLicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGVhbmVkQWRkcmVzcyA9IGFkZHJlc3MudHJpbSgpO1xuICAgICAgXG4gICAgICBpZiAoIS9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGNsZWFuZWRBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXQuJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGxvd2VyY2FzZUFkZHJlc3MgPSBjbGVhbmVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjb25zdCB3YWxsZXRJbmZvOiBXYWxsZXRJbmZvID0ge1xuICAgICAgICBhZGRyZXNzOiBsb3dlcmNhc2VBZGRyZXNzLFxuICAgICAgICBwdWJsaWNLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJvdmlkZXI6ICdtZXRhbWFzaydcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB3YWxsZXRJbmZvO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBXYWxsZXRNYW5hZ2VyOiBDb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QgTWV0YU1hc2s6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBTaWduIGEgbWVzc2FnZSB3aXRoIHdhbGxldFxuICBzdGF0aWMgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZTogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBldGhlcmV1bSA9ICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+Kcje+4jyBXYWxsZXRNYW5hZ2VyOiBTaWduaW5nIG1lc3NhZ2UuLi4nKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ3BlcnNvbmFsX3NpZ24nLFxuICAgICAgICBwYXJhbXM6IFttZXNzYWdlLCBhZGRyZXNzXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgV2FsbGV0TWFuYWdlcjogU2lnbmF0dXJlIHJlY2VpdmVkJyk7XG5cbiAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFdhbGxldE1hbmFnZXI6IE1lc3NhZ2Ugc2lnbmluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzaWduIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIGFjY291bnQgY2hhbmdlc1xuICBzdGF0aWMgb25BY2NvdW50c0NoYW5nZWQoY2FsbGJhY2s6IChhZGRyZXNzZXM6IHN0cmluZ1tdKSA9PiB2b2lkKSB7XG4gICAgaWYgKCF0aGlzLmlzTWV0YU1hc2tBdmFpbGFibGUoKSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGV0aGVyZXVtID0gKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtO1xuICAgIGV0aGVyZXVtLm9uKCdhY2NvdW50c0NoYW5nZWQnLCBjYWxsYmFjayk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChldGhlcmV1bSAmJiBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcignYWNjb3VudHNDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIG5ldHdvcmsgY2hhbmdlc1xuICBzdGF0aWMgb25DaGFpbkNoYW5nZWQoY2FsbGJhY2s6IChjaGFpbklkOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICBpZiAoIXRoaXMuaXNNZXRhTWFza0F2YWlsYWJsZSgpKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgZXRoZXJldW0ub24oJ2NoYWluQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGV0aGVyZXVtICYmIGV0aGVyZXVtLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGV0aGVyZXVtLnJlbW92ZUxpc3RlbmVyKCdjaGFpbkNoYW5nZWQnLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vLyBBUEkgYmFzZSBVUkwgY29uZmlndXJhdGlvblxuY29uc3QgZ2V0QXBpQmFzZVVybCA9ICgpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBuZXh0UHVibGljVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTDtcbiAgY29uc3QgcmVhY3RBcHBVcmwgPSBwcm9jZXNzLmVudi5SRUFDVF9BUFBfQVBJX1VSTDtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5SnIGxpYi9hdXRoLnRzIEVudmlyb25tZW50IENoZWNrOicsIHtcbiAgICBORVhUX1BVQkxJQ19BUElfVVJMOiBuZXh0UHVibGljVXJsLFxuICAgIFJFQUNUX0FQUF9BUElfVVJMOiByZWFjdEFwcFVybCxcbiAgICBOT0RFX0VOVjogcHJvY2Vzcy5lbnYuTk9ERV9FTlZcbiAgfSk7XG5cbiAgY29uc3QgZGVmYXVsdFVybCA9IG5leHRQdWJsaWNVcmwgfHwgcmVhY3RBcHBVcmw7XG4gIFxuICBpZiAoIWRlZmF1bHRVcmwpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCdnaXRodWIuZGV2JykgfHwgaG9zdG5hbWUuaW5jbHVkZXMoJ2dpdHBvZC5pbycpKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke2hvc3RuYW1lLnJlcGxhY2UoJy0zMDAwJywgJy0zMDAxJyl9YDtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflJcgbGliL2F1dGgudHM6IERldGVjdGVkIENvZGVzcGFjZXMvR2l0cG9kLCB1c2luZzonLCBiYXNlVXJsKTtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCfwn5SXIGxpYi9hdXRoLnRzOiBVc2luZyBsb2NhbGhvc3Q6MzAwMScpO1xuICAgIHJldHVybiAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgfVxuICBcbiAgY29uc3QgYmFzZVVybCA9IGRlZmF1bHRVcmwucmVwbGFjZSgvXFwvYXBpLiokLywgJycpO1xuICBjb25zb2xlLmxvZygn8J+UlyBsaWIvYXV0aC50cyB1c2luZyBBUEkgYmFzZSBVUkw6JywgYmFzZVVybCk7XG4gIFxuICByZXR1cm4gYmFzZVVybDtcbn07XG5cbi8vIEF1dGhlbnRpY2F0aW9uIEFQSSBjbGllbnRcbmV4cG9ydCBjbGFzcyBBdXRoQVBJIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0IGJhc2VVUkwoKSB7XG4gICAgcmV0dXJuIGdldEFwaUJhc2VVcmwoKTtcbiAgfVxuXG4gIC8vIOKchSBGSVhFRDogR2VuZXJhdGUgYXV0aGVudGljYXRpb24gY2hhbGxlbmdlIHVzaW5nIHR3by10aWVyIGVuZHBvaW50XG4gIHN0YXRpYyBhc3luYyBnZXRBdXRoQ2hhbGxlbmdlKHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8eyBjaGFsbGVuZ2U6IHN0cmluZzsgdGltZXN0YW1wOiBudW1iZXI7IG5vbmNlOiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC93YWxsZXQvY2hhbGxlbmdlYDsgIC8vIOKchSBDaGFuZ2VkIGZyb20gL2F1dGgvY2hhbGxlbmdlXG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogR2V0dGluZyBhdXRoIGNoYWxsZW5nZSBmcm9tOicsIGZ1bGxVcmwpO1xuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IFdhbGxldCBhZGRyZXNzOicsIHdhbGxldEFkZHJlc3MpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHdhbGxldEFkZHJlc3MgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IENoYWxsZW5nZSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogQ2hhbGxlbmdlIGZhaWxlZDonLCByZXNwb25zZS5zdGF0dXMsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBhdXRoIGNoYWxsZW5nZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIGxpYi9hdXRoLnRzOiBDaGFsbGVuZ2UgZGF0YSByZWNlaXZlZCcpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbGxlbmdlOiBkYXRhLmNoYWxsZW5nZSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wLFxuICAgICAgICAgIG5vbmNlOiBkYXRhLm5vbmNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCByZXNwb25zZSBmcm9tIGF1dGggY2hhbGxlbmdlJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBBdXRoIGNoYWxsZW5nZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyDinIUgRklYRUQ6IFZlcmlmeSBzaWduYXR1cmUgdXNpbmcgdHdvLXRpZXIgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIHZlcmlmeVNpZ25hdHVyZShcbiAgICB3YWxsZXRBZGRyZXNzOiBzdHJpbmcsIFxuICAgIHNpZ25hdHVyZTogc3RyaW5nLCBcbiAgICBjaGFsbGVuZ2U6IHN0cmluZyxcbiAgICB0aW1lc3RhbXA/OiBudW1iZXIsXG4gICAgbm9uY2U/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IHRva2VuOiBzdHJpbmc7IHVzZXI6IFVzZXIgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC93YWxsZXQvdmVyaWZ5YDsgIC8vIOKchSBDaGFuZ2VkIGZyb20gL2F1dGgvbG9naW5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIGxpYi9hdXRoLnRzOiBWZXJpZnlpbmcgc2lnbmF0dXJlIGF0OicsIGZ1bGxVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICAgIHdhbGxldEFkZHJlc3MsIFxuICAgICAgICAgIHNpZ25hdHVyZSwgXG4gICAgICAgICAgY2hhbGxlbmdlLFxuICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICBub25jZVxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogVmVyaWZ5IHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBlcnJvcjogcmVzcG9uc2Uuc3RhdHVzVGV4dCB9KSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogVmVyaWZ5IGZhaWxlZDonLCBlcnJvckRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvckRhdGEuZXJyb3IgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgbGliL2F1dGgudHM6IFZlcmlmeSBkYXRhIHJlY2VpdmVkOicsIGRhdGEpO1xuICAgICAgXG4gICAgICAvLyDinIUgRklYRUQ6IEhhbmRsZSB0d28tdGllciByZXNwb25zZSBmb3JtYXQgd2l0aCBhbGwgZmllbGRzXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEudG9rZW4gJiYgZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW46IGRhdGEudG9rZW4sXG4gICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEudXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBkYXRhLnVzZXIuZGlzcGxheV9uYW1lLFxuICAgICAgICAgICAgdXNlcm5hbWU6IGRhdGEudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIGF2YXRhcl91cmw6IGRhdGEudXNlci5hdmF0YXJfdXJsLFxuICAgICAgICAgICAgYmlvOiBkYXRhLnVzZXIuYmlvLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uX3N0YXR1czogZGF0YS51c2VyLnZlcmlmaWNhdGlvbkxldmVsIHx8ICdiYXNpYycsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBkYXRhLnVzZXIuY3JlYXRlZEF0LFxuICAgICAgICAgICAgLy8g4pyFIFR3by10aWVyIGZpZWxkc1xuICAgICAgICAgICAgb25ib2FyZGluZ19jb21wbGV0ZWQ6IGRhdGEudXNlci5vbmJvYXJkaW5nX2NvbXBsZXRlZCxcbiAgICAgICAgICAgIHByb2ZpbGVDb21wbGV0aW9uOiBkYXRhLnVzZXIucHJvZmlsZUNvbXBsZXRpb24sXG4gICAgICAgICAgICBpc05ld1VzZXI6IGRhdGEuaXNOZXdVc2VyLCAgLy8g4pyFIEZyb20gdG9wLWxldmVsIHJlc3BvbnNlXG4gICAgICAgICAgICBhY2NvdW50VGllcjogZGF0YS51c2VyLmFjY291bnRUaWVyLFxuICAgICAgICAgICAgYXV0aE1ldGhvZDogZGF0YS51c2VyLmF1dGhNZXRob2RcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCByZXNwb25zZSBmcm9tIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IHVzZXIgaW5mb1xuICBzdGF0aWMgYXN5bmMgZ2V0Q3VycmVudFVzZXIodG9rZW46IHN0cmluZyk6IFByb21pc2U8VXNlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9tZWA7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBsaWIvYXV0aC50czogR2V0dGluZyBjdXJyZW50IHVzZXIgZnJvbTonLCBmdWxsVXJsKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHVzZXIgaW5mbzogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEudXNlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXG4gICAgICAgICAgYWRkcmVzczogZGF0YS51c2VyLndhbGxldEFkZHJlc3MsXG4gICAgICAgICAgZW1haWw6IGRhdGEudXNlci5lbWFpbCxcbiAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5kaXNwbGF5X25hbWUsXG4gICAgICAgICAgdXNlcm5hbWU6IGRhdGEudXNlci51c2VybmFtZSxcbiAgICAgICAgICBhdmF0YXJfdXJsOiBkYXRhLnVzZXIuYXZhdGFyX3VybCxcbiAgICAgICAgICB2ZXJpZmljYXRpb25fc3RhdHVzOiAnYmFzaWMnLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGRhdGEudXNlci5jcmVhdGVkX2F0LFxuICAgICAgICAgIC8vIFR3by10aWVyIGZpZWxkc1xuICAgICAgICAgIG9uYm9hcmRpbmdfY29tcGxldGVkOiBkYXRhLnVzZXIub25ib2FyZGluZ19jb21wbGV0ZWQsXG4gICAgICAgICAgcHJvZmlsZUNvbXBsZXRpb246IGRhdGEudXNlci5wcm9maWxlQ29tcGxldGlvbixcbiAgICAgICAgICBhY2NvdW50VGllcjogZGF0YS51c2VyLmFjY291bnRUaWVyLFxuICAgICAgICAgIGF1dGhNZXRob2Q6IGRhdGEudXNlci5hdXRoTWV0aG9kXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCB1c2VyIGRhdGEgcmVjZWl2ZWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdHZXQgY3VycmVudCB1c2VyIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVtYWlsIHNpZ24tdXAgKHR3by10aWVyIGVuZHBvaW50KVxuICBzdGF0aWMgYXN5bmMgZW1haWxTaWdudXAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgZGlzcGxheU5hbWU/OiBzdHJpbmcpOiBQcm9taXNlPHsgdG9rZW46IHN0cmluZzsgdXNlcjogVXNlcjsgaXNOZXdVc2VyOiBib29sZWFuIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk6cgQXV0aEFQSTogRW1haWwgc2lnbi11cCByZXF1ZXN0OicsIGVtYWlsKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL2VtYWlsL3JlZ2lzdGVyYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5OnIEF1dGhBUEk6IFNpZ24tdXAgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBTaWduLXVwIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIEF1dGhBUEk6IEVtYWlsIHNpZ24tdXAgc3VjY2Vzc2Z1bCcpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogZGF0YS50b2tlbixcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXG4gICAgICAgICAgZW1haWw6IGRhdGEudXNlci5lbWFpbCxcbiAgICAgICAgICB1c2VybmFtZTogZGF0YS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZTogZGF0YS51c2VyLmRpc3BsYXlfbmFtZSxcbiAgICAgICAgICBhY2NvdW50VGllcjogZGF0YS51c2VyLmFjY291bnRUaWVyLFxuICAgICAgICAgIGF1dGhNZXRob2Q6IGRhdGEudXNlci5hdXRoTWV0aG9kLFxuICAgICAgICAgIHByb2ZpbGVDb21wbGV0aW9uOiBkYXRhLnVzZXIucHJvZmlsZUNvbXBsZXRpb24sXG4gICAgICAgICAgb25ib2FyZGluZ19jb21wbGV0ZWQ6IGRhdGEudXNlci5vbmJvYXJkaW5nX2NvbXBsZXRlZFxuICAgICAgICB9LFxuICAgICAgICBpc05ld1VzZXI6IGRhdGEuaXNOZXdVc2VyXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQXV0aEFQSTogRW1haWwgc2lnbi11cCBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBFbWFpbCBsb2dpbiAodHdvLXRpZXIgZW5kcG9pbnQpXG4gIHN0YXRpYyBhc3luYyBlbWFpbExvZ2luKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgdG9rZW46IHN0cmluZzsgdXNlcjogVXNlcjsgaXNOZXdVc2VyOiBib29sZWFuIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk6cgQXV0aEFQSTogRW1haWwgbG9naW4gcmVxdWVzdDonLCBlbWFpbCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvYXV0aC9lbWFpbC9sb2dpbmAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/Cfk6cgQXV0aEFQSTogTG9naW4gcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBMb2dpbiBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBBdXRoQVBJOiBFbWFpbCBsb2dpbiBzdWNjZXNzZnVsJyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBkYXRhLnRva2VuLFxuICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICBlbWFpbDogZGF0YS51c2VyLmVtYWlsLFxuICAgICAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgZGlzcGxheV9uYW1lOiBkYXRhLnVzZXIuZGlzcGxheV9uYW1lLFxuICAgICAgICAgIGFjY291bnRUaWVyOiBkYXRhLnVzZXIuYWNjb3VudFRpZXIsXG4gICAgICAgICAgYXV0aE1ldGhvZDogZGF0YS51c2VyLmF1dGhNZXRob2QsXG4gICAgICAgICAgcHJvZmlsZUNvbXBsZXRpb246IGRhdGEudXNlci5wcm9maWxlQ29tcGxldGlvbixcbiAgICAgICAgICBvbmJvYXJkaW5nX2NvbXBsZXRlZDogZGF0YS51c2VyLm9uYm9hcmRpbmdfY29tcGxldGVkXG4gICAgICAgIH0sXG4gICAgICAgIGlzTmV3VXNlcjogZGF0YS5pc05ld1VzZXJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBBdXRoQVBJOiBFbWFpbCBsb2dpbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgSldUIHRva2VuXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlUb2tlbih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTx7IHZhbGlkOiBib29sZWFuOyB1c2VyPzogVXNlciB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxVcmwgPSBgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL3ZlcmlmeWA7XG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBsaWIvYXV0aC50czogVmVyaWZ5aW5nIHRva2VuIGF0OicsIGZ1bGxVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRva2VuIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS52YWxpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgIHVzZXI6IGRhdGEudXNlciA/IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBkYXRhLnVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgIGVtYWlsOiBkYXRhLnVzZXIuZW1haWwsXG4gICAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5kaXNwbGF5X25hbWUsXG4gICAgICAgICAgICB1c2VybmFtZTogZGF0YS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uX3N0YXR1czogJ2Jhc2ljJyxcbiAgICAgICAgICAgIGFjY291bnRUaWVyOiBkYXRhLnVzZXIuYWNjb3VudFRpZXIsXG4gICAgICAgICAgICBhdXRoTWV0aG9kOiBkYXRhLnVzZXIuYXV0aE1ldGhvZFxuICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTG9jYWwgc3RvcmFnZSB1dGlsaXRpZXNcbmV4cG9ydCBjbGFzcyBBdXRoU3RvcmFnZSB7XG4gIHByaXZhdGUgc3RhdGljIFRPS0VOX0tFWSA9ICdvbWVvbmVfYXV0aF90b2tlbic7XG4gIHByaXZhdGUgc3RhdGljIFVTRVJfS0VZID0gJ29tZW9uZV91c2VyJztcblxuICBzdGF0aWMgc2F2ZVRva2VuKHRva2VuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuVE9LRU5fS0VZLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlVG9rZW4oKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRPS0VOX0tFWSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNhdmVVc2VyKHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuVVNFUl9LRVksIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0VXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVVNFUl9LRVkpO1xuICAgICAgaWYgKHVzZXJEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodXNlckRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdG9yZWQgdXNlciBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVVc2VyKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5VU0VSX0tFWSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMucmVtb3ZlVG9rZW4oKTtcbiAgICB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgfVxufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUF1dGhNZXNzYWdlID0gKGNoYWxsZW5nZTogc3RyaW5nLCB3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gY2hhbGxlbmdlO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRFdGhlcmV1bUFkZHJlc3MgPSAoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUNoYWxsZW5nZSA9ICgpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFxuICAgICAgICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFxuICAgICAgICAgRGF0ZS5ub3coKS50b1N0cmluZygzNik7XG59OyJdLCJuYW1lcyI6WyJXYWxsZXRNYW5hZ2VyIiwiaXNNZXRhTWFza0F2YWlsYWJsZSIsIndpbmRvdyIsImV0aGVyZXVtIiwiaXNNZXRhTWFzayIsImNvbm5lY3RNZXRhTWFzayIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsImFkZHJlc3NlcyIsInJlcXVlc3QiLCJtZXRob2QiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJhZGRyZXNzIiwidHJpbSIsImNsZWFuZWRBZGRyZXNzIiwidGVzdCIsImxvd2VyY2FzZUFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsIndhbGxldEluZm8iLCJwdWJsaWNLZXkiLCJ1bmRlZmluZWQiLCJwcm92aWRlciIsImVycm9yIiwibWVzc2FnZSIsInNpZ25NZXNzYWdlIiwic2lnbmF0dXJlIiwicGFyYW1zIiwib25BY2NvdW50c0NoYW5nZWQiLCJjYWxsYmFjayIsIm9uIiwicmVtb3ZlTGlzdGVuZXIiLCJvbkNoYWluQ2hhbmdlZCIsImdldEFwaUJhc2VVcmwiLCJuZXh0UHVibGljVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZWFjdEFwcFVybCIsIlJFQUNUX0FQUF9BUElfVVJMIiwiTk9ERV9FTlYiLCJkZWZhdWx0VXJsIiwiaG9zdG5hbWUiLCJsb2NhdGlvbiIsImluY2x1ZGVzIiwiYmFzZVVybCIsInByb3RvY29sIiwicmVwbGFjZSIsIkF1dGhBUEkiLCJiYXNlVVJMIiwiZ2V0QXV0aENoYWxsZW5nZSIsIndhbGxldEFkZHJlc3MiLCJmdWxsVXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJjcmVkZW50aWFscyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwiY2hhbGxlbmdlIiwidGltZXN0YW1wIiwibm9uY2UiLCJ2ZXJpZnlTaWduYXR1cmUiLCJlcnJvckRhdGEiLCJjYXRjaCIsInN0YXR1c1RleHQiLCJ0b2tlbiIsInVzZXIiLCJpZCIsImRpc3BsYXlfbmFtZSIsInVzZXJuYW1lIiwiYXZhdGFyX3VybCIsImJpbyIsInZlcmlmaWNhdGlvbl9zdGF0dXMiLCJ2ZXJpZmljYXRpb25MZXZlbCIsImNyZWF0ZWRfYXQiLCJjcmVhdGVkQXQiLCJvbmJvYXJkaW5nX2NvbXBsZXRlZCIsInByb2ZpbGVDb21wbGV0aW9uIiwiaXNOZXdVc2VyIiwiYWNjb3VudFRpZXIiLCJhdXRoTWV0aG9kIiwiZ2V0Q3VycmVudFVzZXIiLCJlbWFpbCIsImVtYWlsU2lnbnVwIiwicGFzc3dvcmQiLCJkaXNwbGF5TmFtZSIsImVtYWlsTG9naW4iLCJ2ZXJpZnlUb2tlbiIsInZhbGlkIiwiQXV0aFN0b3JhZ2UiLCJzYXZlVG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiVE9LRU5fS0VZIiwiZ2V0VG9rZW4iLCJnZXRJdGVtIiwicmVtb3ZlVG9rZW4iLCJyZW1vdmVJdGVtIiwic2F2ZVVzZXIiLCJVU0VSX0tFWSIsImdldFVzZXIiLCJ1c2VyRGF0YSIsInBhcnNlIiwicmVtb3ZlVXNlciIsImNsZWFyIiwiY3JlYXRlQXV0aE1lc3NhZ2UiLCJpc1ZhbGlkRXRoZXJldW1BZGRyZXNzIiwiZ2VuZXJhdGVDaGFsbGVuZ2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJEYXRlIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

}]);