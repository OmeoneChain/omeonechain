"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_auth_ts";
exports.ids = ["_ssr_lib_auth_ts"];
exports.modules = {

/***/ "(ssr)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAPI: () => (/* binding */ AuthAPI),\n/* harmony export */   AuthStorage: () => (/* binding */ AuthStorage),\n/* harmony export */   WalletManager: () => (/* binding */ WalletManager),\n/* harmony export */   createAuthMessage: () => (/* binding */ createAuthMessage),\n/* harmony export */   generateChallenge: () => (/* binding */ generateChallenge),\n/* harmony export */   isValidEthereumAddress: () => (/* binding */ isValidEthereumAddress)\n/* harmony export */ });\n// code/poc/frontend/lib/auth.ts\n// FIXED VERSION: Corrected API base URL configuration to prevent double /api/ issue\n// Wallet detection and connection utilities\nclass WalletManager {\n    // Check if MetaMask is available\n    static isMetaMaskAvailable() {\n        return  false && 0;\n    }\n    // Connect to MetaMask\n    static async connectMetaMask() {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not found. Please install MetaMask browser extension.\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            // Request account access\n            const addresses = await ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            if (!addresses || addresses.length === 0) {\n                throw new Error(\"No accounts found. Please unlock MetaMask.\");\n            }\n            const address = addresses[0];\n            // Get the public key if available (optional)\n            let publicKey;\n            try {\n                publicKey = await ethereum.request({\n                    method: \"eth_getEncryptionPublicKey\",\n                    params: [\n                        address\n                    ]\n                });\n            } catch (error) {\n                console.log(\"Could not get public key:\", error);\n            }\n            return {\n                address: address.toLowerCase(),\n                publicKey,\n                provider: \"metamask\"\n            };\n        } catch (error) {\n            console.error(\"MetaMask connection error:\", error);\n            throw new Error(`Failed to connect MetaMask: ${error.message}`);\n        }\n    }\n    // Sign a message with wallet\n    static async signMessage(message, address) {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not available\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            const signature = await ethereum.request({\n                method: \"personal_sign\",\n                params: [\n                    message,\n                    address\n                ]\n            });\n            return signature;\n        } catch (error) {\n            console.error(\"Message signing error:\", error);\n            throw new Error(`Failed to sign message: ${error.message}`);\n        }\n    }\n    // Listen for account changes\n    static onAccountsChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"accountsChanged\", callback);\n        // Return cleanup function\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"accountsChanged\", callback);\n            }\n        };\n    }\n    // Listen for network changes\n    static onChainChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"chainChanged\", callback);\n        // Return cleanup function\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"chainChanged\", callback);\n            }\n        };\n    }\n}\n// FIXED: Corrected URL detection and API base configuration\nconst getApiBaseUrl = ()=>{\n    // Try environment variables in order of preference\n    const nextPublicUrl = \"https://redesigned-lamp-q74wgggqq9jjfxqjp-3001.app.github.dev\";\n    const reactAppUrl = process.env.REACT_APP_API_URL;\n    console.log(\"\\uD83D\\uDD27 lib/auth.ts Environment Check:\", {\n        NEXT_PUBLIC_API_URL: nextPublicUrl,\n        REACT_APP_API_URL: reactAppUrl,\n        NODE_ENV: \"development\",\n        window_location:  false ? 0 : \"SSR\"\n    });\n    // FIXED: Use backend port 3001 (where your Express server runs) WITHOUT extra /api/v1 suffix\n    const defaultUrl = nextPublicUrl || reactAppUrl;\n    // If no env var is set, detect Codespaces URL or use localhost\n    if (!defaultUrl) {\n        if (false) {}\n        return \"http://localhost:3001\"; // FIXED: Backend runs on 3001 without /api/v1 suffix\n    }\n    // FIXED: Ensure URL does NOT have /api/v1 suffix (we'll add it in the API calls)\n    const baseUrl = defaultUrl.replace(/\\/api.*$/, \"\");\n    console.log(\"\\uD83D\\uDD17 lib/auth.ts using API base URL:\", baseUrl);\n    return baseUrl;\n};\n// Authentication API client\nclass AuthAPI {\n    static get baseURL() {\n        return getApiBaseUrl();\n    }\n    // FIXED: Generate authentication challenge with correct endpoint\n    static async getAuthChallenge(walletAddress) {\n        try {\n            const fullUrl = `${this.baseURL}/api/v1/auth/challenge`;\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Getting auth challenge from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Challenge response status:\", response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"❌ lib/auth.ts: Challenge failed:\", response.status, errorText);\n                throw new Error(`Failed to get auth challenge: ${response.status} ${response.statusText} - ${errorText}`);\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Challenge data received:\", data);\n            // FIXED: Handle backend response format\n            if (data.success) {\n                return {\n                    challenge: data.challenge,\n                    timestamp: data.timestamp,\n                    nonce: data.nonce\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response format from auth challenge endpoint\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Auth challenge error:\", error);\n            throw new Error(`Failed to get auth challenge: ${error.message}`);\n        }\n    }\n    // FIXED: Verify signature with correct endpoint\n    static async verifySignature(walletAddress, signature, challenge, timestamp, nonce) {\n        try {\n            const fullUrl = `${this.baseURL}/api/v1/auth/login`;\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verifying signature at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress,\n                    signature,\n                    challenge,\n                    timestamp,\n                    nonce\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verify response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: response.statusText\n                    }));\n                console.error(\"❌ lib/auth.ts: Verify failed:\", errorData);\n                throw new Error(`Authentication failed: ${errorData.error || response.statusText}`);\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Verify data received:\", data);\n            // FIXED: Handle backend response format\n            if (data.success && data.token && data.user) {\n                return {\n                    token: data.token,\n                    user: {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.pseudonym || `User ${data.user.walletAddress.slice(-4)}`,\n                        verification_status: \"basic\",\n                        created_at: new Date().toISOString()\n                    }\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response format from auth verify endpoint\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Signature verification error:\", error);\n            throw new Error(`Authentication failed: ${error.message}`);\n        }\n    }\n    // FIXED: Get current user info with correct endpoint\n    static async getCurrentUser(token) {\n        try {\n            const fullUrl = `${this.baseURL}/api/v1/auth/me`;\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Getting current user from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                headers: {\n                    \"Authorization\": `Bearer ${token}`\n                },\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to get user info: ${response.statusText}`);\n            }\n            const data = await response.json();\n            // FIXED: Handle backend response format\n            if (data.success && data.user) {\n                return {\n                    id: data.user.id,\n                    address: data.user.walletAddress,\n                    display_name: data.user.pseudonym || `User ${data.user.walletAddress.slice(-4)}`,\n                    verification_status: \"basic\",\n                    created_at: data.user.created_at\n                };\n            } else {\n                throw new Error(data.error || \"Invalid user data received\");\n            }\n        } catch (error) {\n            console.error(\"Get current user error:\", error);\n            throw new Error(`Failed to get user info: ${error.message}`);\n        }\n    }\n    // FIXED: Verify JWT token with correct endpoint\n    static async verifyToken(token) {\n        try {\n            const fullUrl = `${this.baseURL}/api/v1/auth/verify`;\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Verifying token at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    token\n                })\n            });\n            if (!response.ok) {\n                return {\n                    valid: false\n                };\n            }\n            const data = await response.json();\n            if (data.success && data.valid) {\n                return {\n                    valid: true,\n                    user: data.user ? {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.pseudonym || `User ${data.user.walletAddress.slice(-4)}`,\n                        verification_status: \"basic\"\n                    } : undefined\n                };\n            } else {\n                return {\n                    valid: false\n                };\n            }\n        } catch (error) {\n            console.error(\"Token verification error:\", error);\n            return {\n                valid: false\n            };\n        }\n    }\n}\n// Local storage utilities\nclass AuthStorage {\n    static{\n        this.TOKEN_KEY = \"omeone_auth_token\";\n    }\n    static{\n        this.USER_KEY = \"omeone_user\";\n    }\n    static saveToken(token) {\n        if (false) {}\n    }\n    static getToken() {\n        if (false) {}\n        return null;\n    }\n    static removeToken() {\n        if (false) {}\n    }\n    static saveUser(user) {\n        if (false) {}\n    }\n    static getUser() {\n        if (false) {}\n        return null;\n    }\n    static removeUser() {\n        if (false) {}\n    }\n    static clear() {\n        this.removeToken();\n        this.removeUser();\n    }\n}\n// FIXED: Utility functions to match backend challenge format\nconst createAuthMessage = (challenge, walletAddress)=>{\n    // This should match the challenge message format from your backend auth routes\n    return challenge; // Backend already provides the complete formatted message\n};\nconst isValidEthereumAddress = (address)=>{\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n};\n// Generate a random challenge string (fallback - backend should handle this)\nconst generateChallenge = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YSxFQUFRO1FBQ3BDLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUNIO0lBRUEsT0FBT29CLFdBQTBCO1FBQy9CLElBQUksS0FBa0IsRUFBYSxFQUVsQztRQUNELE9BQU87SUFDVDtJQUVBLE9BQU9FLGNBQW9CO1FBQ3pCLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUNIO0lBRUEsT0FBT0UsU0FBU3ZCLElBQVUsRUFBUTtRQUNoQyxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDSDtJQUVBLE9BQU93QixVQUF1QjtRQUM1QixJQUFJLEtBQWtCLEVBQWEsRUFVbEM7UUFDRCxPQUFPO0lBQ1Q7SUFFQSxPQUFPRyxhQUFtQjtRQUN4QixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDSDtJQUVBLE9BQU9DLFFBQWM7UUFDbkIsSUFBSSxDQUFDUCxXQUFXO1FBQ2hCLElBQUksQ0FBQ00sVUFBVTtJQUNqQjtBQUNGO0FBRUEsNkRBQTZEO0FBQ3RELE1BQU1FLG9CQUFvQixDQUFDcEMsV0FBbUJqQjtJQUNuRCwrRUFBK0U7SUFDL0UsT0FBT2lCLFdBQVcsMERBQTBEO0FBQzlFLEVBQUU7QUFFSyxNQUFNcUMseUJBQXlCLENBQUMxRjtJQUNyQyxPQUFPLHNCQUFzQjJGLElBQUksQ0FBQzNGO0FBQ3BDLEVBQUU7QUFFRiw2RUFBNkU7QUFDdEUsTUFBTTRGLG9CQUFvQjtJQUMvQixPQUFPQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRyxNQUN4Q0gsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsTUFDeEM3QixLQUFLOEIsR0FBRyxHQUFHRixRQUFRLENBQUM7QUFDN0IsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL29tZW9uZWNoYWluLWZyb250ZW5kLy4vbGliL2F1dGgudHM/YmY3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb2RlL3BvYy9mcm9udGVuZC9saWIvYXV0aC50c1xuLy8gRklYRUQgVkVSU0lPTjogQ29ycmVjdGVkIEFQSSBiYXNlIFVSTCBjb25maWd1cmF0aW9uIHRvIHByZXZlbnQgZG91YmxlIC9hcGkvIGlzc3VlXG5cbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtaG90LXRvYXN0JztcblxuLy8gVHlwZXMgZm9yIGF1dGhlbnRpY2F0aW9uXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nO1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHVzZXJuYW1lPzogc3RyaW5nO1xuICBkaXNwbGF5X25hbWU/OiBzdHJpbmc7XG4gIGF2YXRhcl91cmw/OiBzdHJpbmc7XG4gIHZlcmlmaWNhdGlvbl9zdGF0dXM/OiAnYmFzaWMnIHwgJ3ZlcmlmaWVkJyB8ICdleHBlcnQnO1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhTdGF0ZSB7XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgdG9rZW46IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0SW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgcHVibGljS2V5Pzogc3RyaW5nO1xuICBwcm92aWRlcjogJ21ldGFtYXNrJyB8ICd3YWxsZXRjb25uZWN0JyB8ICdjb2luYmFzZScgfCAnbWFudWFsJztcbn1cblxuLy8gV2FsbGV0IGRldGVjdGlvbiBhbmQgY29ubmVjdGlvbiB1dGlsaXRpZXNcbmV4cG9ydCBjbGFzcyBXYWxsZXRNYW5hZ2VyIHtcbiAgLy8gQ2hlY2sgaWYgTWV0YU1hc2sgaXMgYXZhaWxhYmxlXG4gIHN0YXRpYyBpc01ldGFNYXNrQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBcbiAgICAgICAgICAgdHlwZW9mICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtLmlzTWV0YU1hc2s7XG4gIH1cblxuICAvLyBDb25uZWN0IHRvIE1ldGFNYXNrXG4gIHN0YXRpYyBhc3luYyBjb25uZWN0TWV0YU1hc2soKTogUHJvbWlzZTxXYWxsZXRJbmZvPiB7XG4gICAgaWYgKCF0aGlzLmlzTWV0YU1hc2tBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBub3QgZm91bmQuIFBsZWFzZSBpbnN0YWxsIE1ldGFNYXNrIGJyb3dzZXIgZXh0ZW5zaW9uLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBldGhlcmV1bSA9ICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bTtcbiAgICAgIFxuICAgICAgLy8gUmVxdWVzdCBhY2NvdW50IGFjY2Vzc1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFhZGRyZXNzZXMgfHwgYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIGZvdW5kLiBQbGVhc2UgdW5sb2NrIE1ldGFNYXNrLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc2VzWzBdO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIHB1YmxpYyBrZXkgaWYgYXZhaWxhYmxlIChvcHRpb25hbClcbiAgICAgIGxldCBwdWJsaWNLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHB1YmxpY0tleSA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5JyxcbiAgICAgICAgICBwYXJhbXM6IFthZGRyZXNzXVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZ2V0IHB1YmxpYyBrZXk6JywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgcHJvdmlkZXI6ICdtZXRhbWFzaydcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignTWV0YU1hc2sgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb25uZWN0IE1ldGFNYXNrOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2lnbiBhIG1lc3NhZ2Ugd2l0aCB3YWxsZXRcbiAgc3RhdGljIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2U6IHN0cmluZywgYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNNZXRhTWFza0F2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgICBcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgcGFyYW1zOiBbbWVzc2FnZSwgYWRkcmVzc11cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01lc3NhZ2Ugc2lnbmluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzaWduIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIGFjY291bnQgY2hhbmdlc1xuICBzdGF0aWMgb25BY2NvdW50c0NoYW5nZWQoY2FsbGJhY2s6IChhZGRyZXNzZXM6IHN0cmluZ1tdKSA9PiB2b2lkKSB7XG4gICAgaWYgKCF0aGlzLmlzTWV0YU1hc2tBdmFpbGFibGUoKSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGV0aGVyZXVtID0gKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtO1xuICAgIGV0aGVyZXVtLm9uKCdhY2NvdW50c0NoYW5nZWQnLCBjYWxsYmFjayk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGNsZWFudXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGV0aGVyZXVtICYmIGV0aGVyZXVtLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGV0aGVyZXVtLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3IgbmV0d29yayBjaGFuZ2VzXG4gIHN0YXRpYyBvbkNoYWluQ2hhbmdlZChjYWxsYmFjazogKGNoYWluSWQ6IHN0cmluZykgPT4gdm9pZCkge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBldGhlcmV1bSA9ICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bTtcbiAgICBldGhlcmV1bS5vbignY2hhaW5DaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgIFxuICAgIC8vIFJldHVybiBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChldGhlcmV1bSAmJiBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8gRklYRUQ6IENvcnJlY3RlZCBVUkwgZGV0ZWN0aW9uIGFuZCBBUEkgYmFzZSBjb25maWd1cmF0aW9uXG5jb25zdCBnZXRBcGlCYXNlVXJsID0gKCk6IHN0cmluZyA9PiB7XG4gIC8vIFRyeSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICBjb25zdCBuZXh0UHVibGljVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTDtcbiAgY29uc3QgcmVhY3RBcHBVcmwgPSBwcm9jZXNzLmVudi5SRUFDVF9BUFBfQVBJX1VSTDtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5SnIGxpYi9hdXRoLnRzIEVudmlyb25tZW50IENoZWNrOicsIHtcbiAgICBORVhUX1BVQkxJQ19BUElfVVJMOiBuZXh0UHVibGljVXJsLFxuICAgIFJFQUNUX0FQUF9BUElfVVJMOiByZWFjdEFwcFVybCxcbiAgICBOT0RFX0VOVjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG4gICAgd2luZG93X2xvY2F0aW9uOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogJ1NTUidcbiAgfSk7XG5cbiAgLy8gRklYRUQ6IFVzZSBiYWNrZW5kIHBvcnQgMzAwMSAod2hlcmUgeW91ciBFeHByZXNzIHNlcnZlciBydW5zKSBXSVRIT1VUIGV4dHJhIC9hcGkvdjEgc3VmZml4XG4gIGNvbnN0IGRlZmF1bHRVcmwgPSBuZXh0UHVibGljVXJsIHx8IHJlYWN0QXBwVXJsO1xuICBcbiAgLy8gSWYgbm8gZW52IHZhciBpcyBzZXQsIGRldGVjdCBDb2Rlc3BhY2VzIFVSTCBvciB1c2UgbG9jYWxob3N0XG4gIGlmICghZGVmYXVsdFVybCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgaG9zdG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoJ2dpdGh1Yi5kZXYnKSB8fCBob3N0bmFtZS5pbmNsdWRlcygnZ2l0cG9kLmlvJykpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBDb2Rlc3BhY2VzL0dpdHBvZCBiYXNlIGFuZCBwb2ludCB0byBiYWNrZW5kIHBvcnRcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7aG9zdG5hbWUucmVwbGFjZSgnLTMwMDAnLCAnLTMwMDEnKX1gO1xuICAgICAgICByZXR1cm4gYmFzZVVybDsgLy8gRklYRUQ6IFJldHVybiBiYXNlIFVSTCB3aXRob3V0IC9hcGkvdjEgc3VmZml4XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnaHR0cDovL2xvY2FsaG9zdDozMDAxJzsgLy8gRklYRUQ6IEJhY2tlbmQgcnVucyBvbiAzMDAxIHdpdGhvdXQgL2FwaS92MSBzdWZmaXhcbiAgfVxuICBcbiAgLy8gRklYRUQ6IEVuc3VyZSBVUkwgZG9lcyBOT1QgaGF2ZSAvYXBpL3YxIHN1ZmZpeCAod2UnbGwgYWRkIGl0IGluIHRoZSBBUEkgY2FsbHMpXG4gIGNvbnN0IGJhc2VVcmwgPSBkZWZhdWx0VXJsLnJlcGxhY2UoL1xcL2FwaS4qJC8sICcnKTtcbiAgY29uc29sZS5sb2coJ/CflJcgbGliL2F1dGgudHMgdXNpbmcgQVBJIGJhc2UgVVJMOicsIGJhc2VVcmwpO1xuICBcbiAgcmV0dXJuIGJhc2VVcmw7XG59O1xuXG4vLyBBdXRoZW50aWNhdGlvbiBBUEkgY2xpZW50XG5leHBvcnQgY2xhc3MgQXV0aEFQSSB7XG4gIHByaXZhdGUgc3RhdGljIGdldCBiYXNlVVJMKCkge1xuICAgIHJldHVybiBnZXRBcGlCYXNlVXJsKCk7XG4gIH1cblxuICAvLyBGSVhFRDogR2VuZXJhdGUgYXV0aGVudGljYXRpb24gY2hhbGxlbmdlIHdpdGggY29ycmVjdCBlbmRwb2ludFxuICBzdGF0aWMgYXN5bmMgZ2V0QXV0aENoYWxsZW5nZSh3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHsgY2hhbGxlbmdlOiBzdHJpbmc7IHRpbWVzdGFtcDogbnVtYmVyOyBub25jZTogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL3YxL2F1dGgvY2hhbGxlbmdlYDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIGxpYi9hdXRoLnRzOiBHZXR0aW5nIGF1dGggY2hhbGxlbmdlIGZyb206JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsIC8vIEZJWEVEOiBJbmNsdWRlIGNyZWRlbnRpYWxzIGZvciBDT1JTXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgd2FsbGV0QWRkcmVzcyB9KSwgLy8gRklYRUQ6IE1hdGNoIGJhY2tlbmQgcGFyYW1ldGVyIG5hbWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogQ2hhbGxlbmdlIHJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBDaGFsbGVuZ2UgZmFpbGVkOicsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGF1dGggY2hhbGxlbmdlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAtICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBsaWIvYXV0aC50czogQ2hhbGxlbmdlIGRhdGEgcmVjZWl2ZWQ6JywgZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEZJWEVEOiBIYW5kbGUgYmFja2VuZCByZXNwb25zZSBmb3JtYXRcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFsbGVuZ2U6IGRhdGEuY2hhbGxlbmdlLFxuICAgICAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAsXG4gICAgICAgICAgbm9uY2U6IGRhdGEubm9uY2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIGF1dGggY2hhbGxlbmdlIGVuZHBvaW50Jyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBBdXRoIGNoYWxsZW5nZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgYXV0aCBjaGFsbGVuZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBGSVhFRDogVmVyaWZ5IHNpZ25hdHVyZSB3aXRoIGNvcnJlY3QgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIHZlcmlmeVNpZ25hdHVyZShcbiAgICB3YWxsZXRBZGRyZXNzOiBzdHJpbmcsIFxuICAgIHNpZ25hdHVyZTogc3RyaW5nLCBcbiAgICBjaGFsbGVuZ2U6IHN0cmluZyxcbiAgICB0aW1lc3RhbXA/OiBudW1iZXIsXG4gICAgbm9uY2U/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IHRva2VuOiBzdHJpbmc7IHVzZXI6IFVzZXIgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gYCR7dGhpcy5iYXNlVVJMfS9hcGkvdjEvYXV0aC9sb2dpbmA7XG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogVmVyaWZ5aW5nIHNpZ25hdHVyZSBhdDonLCBmdWxsVXJsKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJywgLy8gRklYRUQ6IEluY2x1ZGUgY3JlZGVudGlhbHMgZm9yIENPUlNcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgICB3YWxsZXRBZGRyZXNzLCBcbiAgICAgICAgICBzaWduYXR1cmUsIFxuICAgICAgICAgIGNoYWxsZW5nZSxcbiAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgbm9uY2VcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IFZlcmlmeSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZXJyb3I6IHJlc3BvbnNlLnN0YXR1c1RleHQgfSkpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgbGliL2F1dGgudHM6IFZlcmlmeSBmYWlsZWQ6JywgZXJyb3JEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JEYXRhLmVycm9yIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIGxpYi9hdXRoLnRzOiBWZXJpZnkgZGF0YSByZWNlaXZlZDonLCBkYXRhKTtcbiAgICAgIFxuICAgICAgLy8gRklYRUQ6IEhhbmRsZSBiYWNrZW5kIHJlc3BvbnNlIGZvcm1hdFxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnRva2VuICYmIGRhdGEudXNlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRva2VuOiBkYXRhLnRva2VuLFxuICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBkYXRhLnVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZGF0YS51c2VyLnBzZXVkb255bSB8fCBgVXNlciAke2RhdGEudXNlci53YWxsZXRBZGRyZXNzLnNsaWNlKC00KX1gLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uX3N0YXR1czogJ2Jhc2ljJyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIGF1dGggdmVyaWZ5IGVuZHBvaW50Jyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRklYRUQ6IEdldCBjdXJyZW50IHVzZXIgaW5mbyB3aXRoIGNvcnJlY3QgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIGdldEN1cnJlbnRVc2VyKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL3YxL2F1dGgvbWVgO1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gbGliL2F1dGgudHM6IEdldHRpbmcgY3VycmVudCB1c2VyIGZyb206JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB1c2VyIGluZm86ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgLy8gRklYRUQ6IEhhbmRsZSBiYWNrZW5kIHJlc3BvbnNlIGZvcm1hdFxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxuICAgICAgICAgIGFkZHJlc3M6IGRhdGEudXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZTogZGF0YS51c2VyLnBzZXVkb255bSB8fCBgVXNlciAke2RhdGEudXNlci53YWxsZXRBZGRyZXNzLnNsaWNlKC00KX1gLFxuICAgICAgICAgIHZlcmlmaWNhdGlvbl9zdGF0dXM6ICdiYXNpYycsXG4gICAgICAgICAgY3JlYXRlZF9hdDogZGF0YS51c2VyLmNyZWF0ZWRfYXRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdJbnZhbGlkIHVzZXIgZGF0YSByZWNlaXZlZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0dldCBjdXJyZW50IHVzZXIgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHVzZXIgaW5mbzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWEVEOiBWZXJpZnkgSldUIHRva2VuIHdpdGggY29ycmVjdCBlbmRwb2ludFxuICBzdGF0aWMgYXN5bmMgdmVyaWZ5VG9rZW4odG9rZW46IHN0cmluZyk6IFByb21pc2U8eyB2YWxpZDogYm9vbGVhbjsgdXNlcj86IFVzZXIgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gYCR7dGhpcy5iYXNlVVJMfS9hcGkvdjEvYXV0aC92ZXJpZnlgO1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gbGliL2F1dGgudHM6IFZlcmlmeWluZyB0b2tlbiBhdDonLCBmdWxsVXJsKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmdWxsVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0b2tlbiB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIgPyB7XG4gICAgICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxuICAgICAgICAgICAgYWRkcmVzczogZGF0YS51c2VyLndhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5wc2V1ZG9ueW0gfHwgYFVzZXIgJHtkYXRhLnVzZXIud2FsbGV0QWRkcmVzcy5zbGljZSgtNCl9YCxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbl9zdGF0dXM6ICdiYXNpYycsXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBMb2NhbCBzdG9yYWdlIHV0aWxpdGllc1xuZXhwb3J0IGNsYXNzIEF1dGhTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgVE9LRU5fS0VZID0gJ29tZW9uZV9hdXRoX3Rva2VuJztcbiAgcHJpdmF0ZSBzdGF0aWMgVVNFUl9LRVkgPSAnb21lb25lX3VzZXInO1xuXG4gIHN0YXRpYyBzYXZlVG9rZW4odG9rZW46IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5UT0tFTl9LRVksIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0VG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5UT0tFTl9LRVkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVUb2tlbigpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2F2ZVVzZXIodXNlcjogVXNlcik6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5VU0VSX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRVc2VyKCk6IFVzZXIgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5VU0VSX0tFWSk7XG4gICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh1c2VyRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIHN0b3JlZCB1c2VyIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlVXNlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIHJlbW92ZVVzZXIoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlVTRVJfS0VZKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5yZW1vdmVUb2tlbigpO1xuICAgIHRoaXMucmVtb3ZlVXNlcigpO1xuICB9XG59XG5cbi8vIEZJWEVEOiBVdGlsaXR5IGZ1bmN0aW9ucyB0byBtYXRjaCBiYWNrZW5kIGNoYWxsZW5nZSBmb3JtYXRcbmV4cG9ydCBjb25zdCBjcmVhdGVBdXRoTWVzc2FnZSA9IChjaGFsbGVuZ2U6IHN0cmluZywgd2FsbGV0QWRkcmVzczogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgLy8gVGhpcyBzaG91bGQgbWF0Y2ggdGhlIGNoYWxsZW5nZSBtZXNzYWdlIGZvcm1hdCBmcm9tIHlvdXIgYmFja2VuZCBhdXRoIHJvdXRlc1xuICByZXR1cm4gY2hhbGxlbmdlOyAvLyBCYWNrZW5kIGFscmVhZHkgcHJvdmlkZXMgdGhlIGNvbXBsZXRlIGZvcm1hdHRlZCBtZXNzYWdlXG59O1xuXG5leHBvcnQgY29uc3QgaXNWYWxpZEV0aGVyZXVtQWRkcmVzcyA9IChhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGFkZHJlc3MpO1xufTtcblxuLy8gR2VuZXJhdGUgYSByYW5kb20gY2hhbGxlbmdlIHN0cmluZyAoZmFsbGJhY2sgLSBiYWNrZW5kIHNob3VsZCBoYW5kbGUgdGhpcylcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUNoYWxsZW5nZSA9ICgpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFxuICAgICAgICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFxuICAgICAgICAgRGF0ZS5ub3coKS50b1N0cmluZygzNik7XG59OyJdLCJuYW1lcyI6WyJXYWxsZXRNYW5hZ2VyIiwiaXNNZXRhTWFza0F2YWlsYWJsZSIsIndpbmRvdyIsImV0aGVyZXVtIiwiaXNNZXRhTWFzayIsImNvbm5lY3RNZXRhTWFzayIsIkVycm9yIiwiYWRkcmVzc2VzIiwicmVxdWVzdCIsIm1ldGhvZCIsImxlbmd0aCIsImFkZHJlc3MiLCJwdWJsaWNLZXkiLCJwYXJhbXMiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0b0xvd2VyQ2FzZSIsInByb3ZpZGVyIiwibWVzc2FnZSIsInNpZ25NZXNzYWdlIiwic2lnbmF0dXJlIiwib25BY2NvdW50c0NoYW5nZWQiLCJjYWxsYmFjayIsIm9uIiwicmVtb3ZlTGlzdGVuZXIiLCJvbkNoYWluQ2hhbmdlZCIsImdldEFwaUJhc2VVcmwiLCJuZXh0UHVibGljVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZWFjdEFwcFVybCIsIlJFQUNUX0FQUF9BUElfVVJMIiwiTk9ERV9FTlYiLCJ3aW5kb3dfbG9jYXRpb24iLCJsb2NhdGlvbiIsImhyZWYiLCJkZWZhdWx0VXJsIiwiaG9zdG5hbWUiLCJpbmNsdWRlcyIsImJhc2VVcmwiLCJwcm90b2NvbCIsInJlcGxhY2UiLCJBdXRoQVBJIiwiYmFzZVVSTCIsImdldEF1dGhDaGFsbGVuZ2UiLCJ3YWxsZXRBZGRyZXNzIiwiZnVsbFVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwiY3JlZGVudGlhbHMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXR1cyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsInN1Y2Nlc3MiLCJjaGFsbGVuZ2UiLCJ0aW1lc3RhbXAiLCJub25jZSIsInZlcmlmeVNpZ25hdHVyZSIsImVycm9yRGF0YSIsImNhdGNoIiwidG9rZW4iLCJ1c2VyIiwiaWQiLCJkaXNwbGF5X25hbWUiLCJwc2V1ZG9ueW0iLCJzbGljZSIsInZlcmlmaWNhdGlvbl9zdGF0dXMiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZ2V0Q3VycmVudFVzZXIiLCJ2ZXJpZnlUb2tlbiIsInZhbGlkIiwidW5kZWZpbmVkIiwiQXV0aFN0b3JhZ2UiLCJUT0tFTl9LRVkiLCJVU0VSX0tFWSIsInNhdmVUb2tlbiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJnZXRUb2tlbiIsImdldEl0ZW0iLCJyZW1vdmVUb2tlbiIsInJlbW92ZUl0ZW0iLCJzYXZlVXNlciIsImdldFVzZXIiLCJ1c2VyRGF0YSIsInBhcnNlIiwicmVtb3ZlVXNlciIsImNsZWFyIiwiY3JlYXRlQXV0aE1lc3NhZ2UiLCJpc1ZhbGlkRXRoZXJldW1BZGRyZXNzIiwidGVzdCIsImdlbmVyYXRlQ2hhbGxlbmdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./lib/auth.ts\n");

/***/ })

};
;