"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_auth_ts";
exports.ids = ["_ssr_lib_auth_ts"];
exports.modules = {

/***/ "(ssr)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAPI: () => (/* binding */ AuthAPI),\n/* harmony export */   AuthStorage: () => (/* binding */ AuthStorage),\n/* harmony export */   WalletManager: () => (/* binding */ WalletManager),\n/* harmony export */   createAuthMessage: () => (/* binding */ createAuthMessage),\n/* harmony export */   generateChallenge: () => (/* binding */ generateChallenge),\n/* harmony export */   isValidEthereumAddress: () => (/* binding */ isValidEthereumAddress)\n/* harmony export */ });\n// code/poc/frontend/lib/auth.ts\n// FIXED VERSION: Corrected API base URL configuration to prevent double /api/ issue\n// Wallet detection and connection utilities\nclass WalletManager {\n    // Check if MetaMask is available\n    static isMetaMaskAvailable() {\n        return  false && 0;\n    }\n    // Connect to MetaMask\n    static async connectMetaMask() {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not found. Please install MetaMask browser extension.\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            // Request account access\n            const addresses = await ethereum.request({\n                method: \"eth_requestAccounts\"\n            });\n            if (!addresses || addresses.length === 0) {\n                throw new Error(\"No accounts found. Please unlock MetaMask.\");\n            }\n            const address = addresses[0];\n            // Get the public key if available (optional)\n            let publicKey;\n            try {\n                publicKey = await ethereum.request({\n                    method: \"eth_getEncryptionPublicKey\",\n                    params: [\n                        address\n                    ]\n                });\n            } catch (error) {\n                console.log(\"Could not get public key:\", error);\n            }\n            return {\n                address: address.toLowerCase(),\n                publicKey,\n                provider: \"metamask\"\n            };\n        } catch (error) {\n            console.error(\"MetaMask connection error:\", error);\n            throw new Error(`Failed to connect MetaMask: ${error.message}`);\n        }\n    }\n    // Sign a message with wallet\n    static async signMessage(message, address) {\n        if (!this.isMetaMaskAvailable()) {\n            throw new Error(\"MetaMask not available\");\n        }\n        try {\n            const ethereum = window.ethereum;\n            const signature = await ethereum.request({\n                method: \"personal_sign\",\n                params: [\n                    message,\n                    address\n                ]\n            });\n            return signature;\n        } catch (error) {\n            console.error(\"Message signing error:\", error);\n            throw new Error(`Failed to sign message: ${error.message}`);\n        }\n    }\n    // Listen for account changes\n    static onAccountsChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"accountsChanged\", callback);\n        // Return cleanup function\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"accountsChanged\", callback);\n            }\n        };\n    }\n    // Listen for network changes\n    static onChainChanged(callback) {\n        if (!this.isMetaMaskAvailable()) return;\n        const ethereum = window.ethereum;\n        ethereum.on(\"chainChanged\", callback);\n        // Return cleanup function\n        return ()=>{\n            if (ethereum && ethereum.removeListener) {\n                ethereum.removeListener(\"chainChanged\", callback);\n            }\n        };\n    }\n}\n// FIXED: Corrected URL detection and API base configuration\nconst getApiBaseUrl = ()=>{\n    // Try environment variables in order of preference\n    const nextPublicUrl = \"https://redesigned-lamp-q74wgggqq9jjfxqjp-3001.app.github.dev\";\n    const reactAppUrl = process.env.REACT_APP_API_URL;\n    console.log(\"\\uD83D\\uDD27 lib/auth.ts Environment Check:\", {\n        NEXT_PUBLIC_API_URL: nextPublicUrl,\n        REACT_APP_API_URL: reactAppUrl,\n        NODE_ENV: \"development\",\n        window_location:  false ? 0 : \"SSR\"\n    });\n    // FIXED: Use backend port 3001 (where your Express server runs) WITHOUT extra /api suffix\n    const defaultUrl = nextPublicUrl || reactAppUrl;\n    // If no env var is set, detect Codespaces URL or use localhost\n    if (!defaultUrl) {\n        if (false) {}\n        return \"http://localhost:3001\"; // FIXED: Backend runs on 3001 without /api suffix\n    }\n    // FIXED: Ensure URL does NOT have /api suffix (we'll add it in the API calls)\n    const baseUrl = defaultUrl.replace(/\\/api.*$/, \"\");\n    console.log(\"\\uD83D\\uDD17 lib/auth.ts using API base URL:\", baseUrl);\n    return baseUrl;\n};\n// Authentication API client\nclass AuthAPI {\n    static get baseURL() {\n        return getApiBaseUrl();\n    }\n    // FIXED: Generate authentication challenge with correct endpoint\n    static async getAuthChallenge(walletAddress) {\n        try {\n            const fullUrl = `${this.baseURL}/api/auth/challenge`;\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Getting auth challenge from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Challenge response status:\", response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"❌ lib/auth.ts: Challenge failed:\", response.status, errorText);\n                throw new Error(`Failed to get auth challenge: ${response.status} ${response.statusText} - ${errorText}`);\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Challenge data received:\", data);\n            // FIXED: Handle backend response format\n            if (data.success) {\n                return {\n                    challenge: data.challenge,\n                    timestamp: data.timestamp,\n                    nonce: data.nonce\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response format from auth challenge endpoint\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Auth challenge error:\", error);\n            throw new Error(`Failed to get auth challenge: ${error.message}`);\n        }\n    }\n    // FIXED: Verify signature with correct endpoint\n    static async verifySignature(walletAddress, signature, challenge, timestamp, nonce) {\n        try {\n            const fullUrl = `${this.baseURL}/api/auth/login`;\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verifying signature at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    walletAddress,\n                    signature,\n                    challenge,\n                    timestamp,\n                    nonce\n                })\n            });\n            console.log(\"\\uD83D\\uDD10 lib/auth.ts: Verify response status:\", response.status);\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: response.statusText\n                    }));\n                console.error(\"❌ lib/auth.ts: Verify failed:\", errorData);\n                throw new Error(`Authentication failed: ${errorData.error || response.statusText}`);\n            }\n            const data = await response.json();\n            console.log(\"✅ lib/auth.ts: Verify data received:\", data);\n            // FIXED: Handle backend response format\n            if (data.success && data.token && data.user) {\n                return {\n                    token: data.token,\n                    user: {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.pseudonym || `User ${data.user.walletAddress.slice(-4)}`,\n                        verification_status: \"basic\",\n                        created_at: new Date().toISOString()\n                    }\n                };\n            } else {\n                throw new Error(data.error || \"Invalid response format from auth verify endpoint\");\n            }\n        } catch (error) {\n            console.error(\"❌ lib/auth.ts: Signature verification error:\", error);\n            throw new Error(`Authentication failed: ${error.message}`);\n        }\n    }\n    // FIXED: Get current user info with correct endpoint\n    static async getCurrentUser(token) {\n        try {\n            const fullUrl = `${this.baseURL}/api/auth/me`;\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Getting current user from:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                headers: {\n                    \"Authorization\": `Bearer ${token}`\n                },\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to get user info: ${response.statusText}`);\n            }\n            const data = await response.json();\n            // FIXED: Handle backend response format\n            if (data.success && data.user) {\n                return {\n                    id: data.user.id,\n                    address: data.user.walletAddress,\n                    display_name: data.user.pseudonym || `User ${data.user.walletAddress.slice(-4)}`,\n                    verification_status: \"basic\",\n                    created_at: data.user.created_at\n                };\n            } else {\n                throw new Error(data.error || \"Invalid user data received\");\n            }\n        } catch (error) {\n            console.error(\"Get current user error:\", error);\n            throw new Error(`Failed to get user info: ${error.message}`);\n        }\n    }\n    // FIXED: Verify JWT token with correct endpoint\n    static async verifyToken(token) {\n        try {\n            const fullUrl = `${this.baseURL}/api/auth/verify`;\n            console.log(\"\\uD83D\\uDD0D lib/auth.ts: Verifying token at:\", fullUrl);\n            const response = await fetch(fullUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    token\n                })\n            });\n            if (!response.ok) {\n                return {\n                    valid: false\n                };\n            }\n            const data = await response.json();\n            if (data.success && data.valid) {\n                return {\n                    valid: true,\n                    user: data.user ? {\n                        id: data.user.id,\n                        address: data.user.walletAddress,\n                        display_name: data.user.pseudonym || `User ${data.user.walletAddress.slice(-4)}`,\n                        verification_status: \"basic\"\n                    } : undefined\n                };\n            } else {\n                return {\n                    valid: false\n                };\n            }\n        } catch (error) {\n            console.error(\"Token verification error:\", error);\n            return {\n                valid: false\n            };\n        }\n    }\n}\n// Local storage utilities\nclass AuthStorage {\n    static{\n        this.TOKEN_KEY = \"omeone_auth_token\";\n    }\n    static{\n        this.USER_KEY = \"omeone_user\";\n    }\n    static saveToken(token) {\n        if (false) {}\n    }\n    static getToken() {\n        if (false) {}\n        return null;\n    }\n    static removeToken() {\n        if (false) {}\n    }\n    static saveUser(user) {\n        if (false) {}\n    }\n    static getUser() {\n        if (false) {}\n        return null;\n    }\n    static removeUser() {\n        if (false) {}\n    }\n    static clear() {\n        this.removeToken();\n        this.removeUser();\n    }\n}\n// FIXED: Utility functions to match backend challenge format\nconst createAuthMessage = (challenge, walletAddress)=>{\n    // This should match the challenge message format from your backend auth routes\n    return challenge; // Backend already provides the complete formatted message\n};\nconst isValidEthereumAddress = (address)=>{\n    return /^0x[a-fA-F0-9]{40}$/.test(address);\n};\n// Generate a random challenge string (fallback - backend should handle this)\nconst generateChallenge = ()=>{\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Date.now().toString(36);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9saWIvYXV0aC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxnQ0FBZ0M7QUFDaEMsb0ZBQW9GO0FBNEJwRiw0Q0FBNEM7QUFDckMsTUFBTUE7SUFDWCxpQ0FBaUM7SUFDakMsT0FBT0Msc0JBQStCO1FBQ3BDLE9BQU8sTUFDb0MsSUFDcEMsQ0FBbUM7SUFDNUM7SUFFQSxzQkFBc0I7SUFDdEIsYUFBYUksa0JBQXVDO1FBQ2xELElBQUksQ0FBQyxJQUFJLENBQUNKLG1CQUFtQixJQUFJO1lBQy9CLE1BQU0sSUFBSUssTUFBTTtRQUNsQjtRQUVBLElBQUk7WUFDRixNQUFNSCxXQUFXLE9BQWdCQSxRQUFRO1lBRXpDLHlCQUF5QjtZQUN6QixNQUFNSSxZQUFZLE1BQU1KLFNBQVNLLE9BQU8sQ0FBQztnQkFDdkNDLFFBQVE7WUFDVjtZQUVBLElBQUksQ0FBQ0YsYUFBYUEsVUFBVUcsTUFBTSxLQUFLLEdBQUc7Z0JBQ3hDLE1BQU0sSUFBSUosTUFBTTtZQUNsQjtZQUVBLE1BQU1LLFVBQVVKLFNBQVMsQ0FBQyxFQUFFO1lBRTVCLDZDQUE2QztZQUM3QyxJQUFJSztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksTUFBTVQsU0FBU0ssT0FBTyxDQUFDO29CQUNqQ0MsUUFBUTtvQkFDUkksUUFBUTt3QkFBQ0Y7cUJBQVE7Z0JBQ25CO1lBQ0YsRUFBRSxPQUFPRyxPQUFPO2dCQUNkQyxRQUFRQyxHQUFHLENBQUMsNkJBQTZCRjtZQUMzQztZQUVBLE9BQU87Z0JBQ0xILFNBQVNBLFFBQVFNLFdBQVc7Z0JBQzVCTDtnQkFDQU0sVUFBVTtZQUNaO1FBQ0YsRUFBRSxPQUFPSixPQUFZO1lBQ25CQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtZQUM1QyxNQUFNLElBQUlSLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRVEsTUFBTUssT0FBTyxDQUFDLENBQUM7UUFDaEU7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QixhQUFhQyxZQUFZRCxPQUFlLEVBQUVSLE9BQWUsRUFBbUI7UUFDMUUsSUFBSSxDQUFDLElBQUksQ0FBQ1YsbUJBQW1CLElBQUk7WUFDL0IsTUFBTSxJQUFJSyxNQUFNO1FBQ2xCO1FBRUEsSUFBSTtZQUNGLE1BQU1ILFdBQVcsT0FBZ0JBLFFBQVE7WUFFekMsTUFBTWtCLFlBQVksTUFBTWxCLFNBQVNLLE9BQU8sQ0FBQztnQkFDdkNDLFFBQVE7Z0JBQ1JJLFFBQVE7b0JBQUNNO29CQUFTUjtpQkFBUTtZQUM1QjtZQUVBLE9BQU9VO1FBQ1QsRUFBRSxPQUFPUCxPQUFZO1lBQ25CQyxRQUFRRCxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxNQUFNLElBQUlSLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRVEsTUFBTUssT0FBTyxDQUFDLENBQUM7UUFDNUQ7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QixPQUFPRyxrQkFBa0JDLFFBQXVDLEVBQUU7UUFDaEUsSUFBSSxDQUFDLElBQUksQ0FBQ3RCLG1CQUFtQixJQUFJO1FBRWpDLE1BQU1FLFdBQVcsT0FBZ0JBLFFBQVE7UUFDekNBLFNBQVNxQixFQUFFLENBQUMsbUJBQW1CRDtRQUUvQiwwQkFBMEI7UUFDMUIsT0FBTztZQUNMLElBQUlwQixZQUFZQSxTQUFTc0IsY0FBYyxFQUFFO2dCQUN2Q3RCLFNBQVNzQixjQUFjLENBQUMsbUJBQW1CRjtZQUM3QztRQUNGO0lBQ0Y7SUFFQSw2QkFBNkI7SUFDN0IsT0FBT0csZUFBZUgsUUFBbUMsRUFBRTtRQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDdEIsbUJBQW1CLElBQUk7UUFFakMsTUFBTUUsV0FBVyxPQUFnQkEsUUFBUTtRQUN6Q0EsU0FBU3FCLEVBQUUsQ0FBQyxnQkFBZ0JEO1FBRTVCLDBCQUEwQjtRQUMxQixPQUFPO1lBQ0wsSUFBSXBCLFlBQVlBLFNBQVNzQixjQUFjLEVBQUU7Z0JBQ3ZDdEIsU0FBU3NCLGNBQWMsQ0FBQyxnQkFBZ0JGO1lBQzFDO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsNERBQTREO0FBQzVELE1BQU1JLGdCQUFnQjtJQUNwQixtREFBbUQ7SUFDbkQsTUFBTUMsZ0JBQWdCQywrREFBK0I7SUFDckQsTUFBTUcsY0FBY0gsUUFBUUMsR0FBRyxDQUFDRyxpQkFBaUI7SUFFakRsQixRQUFRQyxHQUFHLENBQUMsK0NBQXFDO1FBQy9DZSxxQkFBcUJIO1FBQ3JCSyxtQkFBbUJEO1FBQ25CRSxVQTdJSjtRQThJSUMsaUJBQWlCLE1BQWtCLEdBQWNqQyxDQUFvQixHQUFHO0lBQzFFO0lBRUEsMEZBQTBGO0lBQzFGLE1BQU1vQyxhQUFhVixpQkFBaUJJO0lBRXBDLCtEQUErRDtJQUMvRCxJQUFJLENBQUNNLFlBQVk7UUFDZixJQUFJLEtBQWtCLEVBQWEsRUFPbEM7UUFDRCxPQUFPLHlCQUF5QixrREFBa0Q7SUFDcEY7SUFFQSw4RUFBOEU7SUFDOUUsTUFBTUcsVUFBVUgsV0FBV0ssT0FBTyxDQUFDLFlBQVk7SUFDL0M1QixRQUFRQyxHQUFHLENBQUMsZ0RBQXNDeUI7SUFFbEQsT0FBT0E7QUFDVDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNRztJQUNYLFdBQW1CQyxVQUFVO1FBQzNCLE9BQU9sQjtJQUNUO0lBRUEsaUVBQWlFO0lBQ2pFLGFBQWFtQixpQkFBaUJDLGFBQXFCLEVBQW9FO1FBQ3JILElBQUk7WUFDRixNQUFNQyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUNILE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztZQUNwRDlCLFFBQVFDLEdBQUcsQ0FBQywwREFBZ0RnQztZQUU1RCxNQUFNQyxXQUFXLE1BQU1DLE1BQU1GLFNBQVM7Z0JBQ3BDdkMsUUFBUTtnQkFDUjBDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtnQkFDQUMsYUFBYTtnQkFDYkMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFUjtnQkFBYztZQUN2QztZQUVBaEMsUUFBUUMsR0FBRyxDQUFDLHdEQUE4Q2lDLFNBQVNPLE1BQU07WUFFekUsSUFBSSxDQUFDUCxTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVQsU0FBU1UsSUFBSTtnQkFDckM1QyxRQUFRRCxLQUFLLENBQUMsb0NBQW9DbUMsU0FBU08sTUFBTSxFQUFFRTtnQkFDbkUsTUFBTSxJQUFJcEQsTUFBTSxDQUFDLDhCQUE4QixFQUFFMkMsU0FBU08sTUFBTSxDQUFDLENBQUMsRUFBRVAsU0FBU1csVUFBVSxDQUFDLEdBQUcsRUFBRUYsVUFBVSxDQUFDO1lBQzFHO1lBRUEsTUFBTUcsT0FBTyxNQUFNWixTQUFTYSxJQUFJO1lBQ2hDL0MsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQzZDO1lBRXZELHdDQUF3QztZQUN4QyxJQUFJQSxLQUFLRSxPQUFPLEVBQUU7Z0JBQ2hCLE9BQU87b0JBQ0xDLFdBQVdILEtBQUtHLFNBQVM7b0JBQ3pCQyxXQUFXSixLQUFLSSxTQUFTO29CQUN6QkMsT0FBT0wsS0FBS0ssS0FBSztnQkFDbkI7WUFDRixPQUFPO2dCQUNMLE1BQU0sSUFBSTVELE1BQU11RCxLQUFLL0MsS0FBSyxJQUFJO1lBQ2hDO1FBQ0YsRUFBRSxPQUFPQSxPQUFZO1lBQ25CQyxRQUFRRCxLQUFLLENBQUMsd0NBQXdDQTtZQUN0RCxNQUFNLElBQUlSLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRVEsTUFBTUssT0FBTyxDQUFDLENBQUM7UUFDbEU7SUFDRjtJQUVBLGdEQUFnRDtJQUNoRCxhQUFhZ0QsZ0JBQ1hwQixhQUFxQixFQUNyQjFCLFNBQWlCLEVBQ2pCMkMsU0FBaUIsRUFDakJDLFNBQWtCLEVBQ2xCQyxLQUFjLEVBQzBCO1FBQ3hDLElBQUk7WUFDRixNQUFNbEIsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDSCxPQUFPLENBQUMsZUFBZSxDQUFDO1lBQ2hEOUIsUUFBUUMsR0FBRyxDQUFDLHFEQUEyQ2dDO1lBRXZELE1BQU1DLFdBQVcsTUFBTUMsTUFBTUYsU0FBUztnQkFDcEN2QyxRQUFRO2dCQUNSMEMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxhQUFhO2dCQUNiQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQ25CUjtvQkFDQTFCO29CQUNBMkM7b0JBQ0FDO29CQUNBQztnQkFDRjtZQUNGO1lBRUFuRCxRQUFRQyxHQUFHLENBQUMscURBQTJDaUMsU0FBU08sTUFBTTtZQUV0RSxJQUFJLENBQUNQLFNBQVNRLEVBQUUsRUFBRTtnQkFDaEIsTUFBTVcsWUFBWSxNQUFNbkIsU0FBU2EsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTzt3QkFBRXZELE9BQU9tQyxTQUFTVyxVQUFVO29CQUFDO2dCQUNsRjdDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNzRDtnQkFDL0MsTUFBTSxJQUFJOUQsTUFBTSxDQUFDLHVCQUF1QixFQUFFOEQsVUFBVXRELEtBQUssSUFBSW1DLFNBQVNXLFVBQVUsQ0FBQyxDQUFDO1lBQ3BGO1lBRUEsTUFBTUMsT0FBTyxNQUFNWixTQUFTYSxJQUFJO1lBQ2hDL0MsUUFBUUMsR0FBRyxDQUFDLHdDQUF3QzZDO1lBRXBELHdDQUF3QztZQUN4QyxJQUFJQSxLQUFLRSxPQUFPLElBQUlGLEtBQUtTLEtBQUssSUFBSVQsS0FBS1UsSUFBSSxFQUFFO2dCQUMzQyxPQUFPO29CQUNMRCxPQUFPVCxLQUFLUyxLQUFLO29CQUNqQkMsTUFBTTt3QkFDSkMsSUFBSVgsS0FBS1UsSUFBSSxDQUFDQyxFQUFFO3dCQUNoQjdELFNBQVNrRCxLQUFLVSxJQUFJLENBQUN4QixhQUFhO3dCQUNoQzBCLGNBQWNaLEtBQUtVLElBQUksQ0FBQ0csU0FBUyxJQUFJLENBQUMsS0FBSyxFQUFFYixLQUFLVSxJQUFJLENBQUN4QixhQUFhLENBQUM0QixLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7d0JBQ2hGQyxxQkFBcUI7d0JBQ3JCQyxZQUFZLElBQUlDLE9BQU9DLFdBQVc7b0JBQ3BDO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxNQUFNLElBQUl6RSxNQUFNdUQsS0FBSy9DLEtBQUssSUFBSTtZQUNoQztRQUNGLEVBQUUsT0FBT0EsT0FBWTtZQUNuQkMsUUFBUUQsS0FBSyxDQUFDLGdEQUFnREE7WUFDOUQsTUFBTSxJQUFJUixNQUFNLENBQUMsdUJBQXVCLEVBQUVRLE1BQU1LLE9BQU8sQ0FBQyxDQUFDO1FBQzNEO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsYUFBYTZELGVBQWVWLEtBQWEsRUFBaUI7UUFDeEQsSUFBSTtZQUNGLE1BQU10QixVQUFVLENBQUMsRUFBRSxJQUFJLENBQUNILE9BQU8sQ0FBQyxZQUFZLENBQUM7WUFDN0M5QixRQUFRQyxHQUFHLENBQUMsd0RBQThDZ0M7WUFFMUQsTUFBTUMsV0FBVyxNQUFNQyxNQUFNRixTQUFTO2dCQUNwQ0csU0FBUztvQkFDUCxpQkFBaUIsQ0FBQyxPQUFPLEVBQUVtQixNQUFNLENBQUM7Z0JBQ3BDO2dCQUNBbEIsYUFBYTtZQUNmO1lBRUEsSUFBSSxDQUFDSCxTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSW5ELE1BQU0sQ0FBQyx5QkFBeUIsRUFBRTJDLFNBQVNXLFVBQVUsQ0FBQyxDQUFDO1lBQ25FO1lBRUEsTUFBTUMsT0FBTyxNQUFNWixTQUFTYSxJQUFJO1lBRWhDLHdDQUF3QztZQUN4QyxJQUFJRCxLQUFLRSxPQUFPLElBQUlGLEtBQUtVLElBQUksRUFBRTtnQkFDN0IsT0FBTztvQkFDTEMsSUFBSVgsS0FBS1UsSUFBSSxDQUFDQyxFQUFFO29CQUNoQjdELFNBQVNrRCxLQUFLVSxJQUFJLENBQUN4QixhQUFhO29CQUNoQzBCLGNBQWNaLEtBQUtVLElBQUksQ0FBQ0csU0FBUyxJQUFJLENBQUMsS0FBSyxFQUFFYixLQUFLVSxJQUFJLENBQUN4QixhQUFhLENBQUM0QixLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7b0JBQ2hGQyxxQkFBcUI7b0JBQ3JCQyxZQUFZaEIsS0FBS1UsSUFBSSxDQUFDTSxVQUFVO2dCQUNsQztZQUNGLE9BQU87Z0JBQ0wsTUFBTSxJQUFJdkUsTUFBTXVELEtBQUsvQyxLQUFLLElBQUk7WUFDaEM7UUFDRixFQUFFLE9BQU9BLE9BQVk7WUFDbkJDLFFBQVFELEtBQUssQ0FBQywyQkFBMkJBO1lBQ3pDLE1BQU0sSUFBSVIsTUFBTSxDQUFDLHlCQUF5QixFQUFFUSxNQUFNSyxPQUFPLENBQUMsQ0FBQztRQUM3RDtJQUNGO0lBRUEsZ0RBQWdEO0lBQ2hELGFBQWE4RCxZQUFZWCxLQUFhLEVBQTRDO1FBQ2hGLElBQUk7WUFDRixNQUFNdEIsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDSCxPQUFPLENBQUMsZ0JBQWdCLENBQUM7WUFDakQ5QixRQUFRQyxHQUFHLENBQUMsaURBQXVDZ0M7WUFFbkQsTUFBTUMsV0FBVyxNQUFNQyxNQUFNRixTQUFTO2dCQUNwQ3ZDLFFBQVE7Z0JBQ1IwQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLGFBQWE7Z0JBQ2JDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRWU7Z0JBQU07WUFDL0I7WUFFQSxJQUFJLENBQUNyQixTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE9BQU87b0JBQUV5QixPQUFPO2dCQUFNO1lBQ3hCO1lBRUEsTUFBTXJCLE9BQU8sTUFBTVosU0FBU2EsSUFBSTtZQUVoQyxJQUFJRCxLQUFLRSxPQUFPLElBQUlGLEtBQUtxQixLQUFLLEVBQUU7Z0JBQzlCLE9BQU87b0JBQ0xBLE9BQU87b0JBQ1BYLE1BQU1WLEtBQUtVLElBQUksR0FBRzt3QkFDaEJDLElBQUlYLEtBQUtVLElBQUksQ0FBQ0MsRUFBRTt3QkFDaEI3RCxTQUFTa0QsS0FBS1UsSUFBSSxDQUFDeEIsYUFBYTt3QkFDaEMwQixjQUFjWixLQUFLVSxJQUFJLENBQUNHLFNBQVMsSUFBSSxDQUFDLEtBQUssRUFBRWIsS0FBS1UsSUFBSSxDQUFDeEIsYUFBYSxDQUFDNEIsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO3dCQUNoRkMscUJBQXFCO29CQUN2QixJQUFJTztnQkFDTjtZQUNGLE9BQU87Z0JBQ0wsT0FBTztvQkFBRUQsT0FBTztnQkFBTTtZQUN4QjtRQUNGLEVBQUUsT0FBT3BFLE9BQVk7WUFDbkJDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE9BQU87Z0JBQUVvRSxPQUFPO1lBQU07UUFDeEI7SUFDRjtBQUNGO0FBRUEsMEJBQTBCO0FBQ25CLE1BQU1FOzthQUNJQyxZQUFZOzs7YUFDWkMsV0FBVzs7SUFFMUIsT0FBT0MsVUFBVWpCLEtBQWEsRUFBUTtRQUNwQyxJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDSDtJQUVBLE9BQU9vQixXQUEwQjtRQUMvQixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7UUFDRCxPQUFPO0lBQ1Q7SUFFQSxPQUFPRSxjQUFvQjtRQUN6QixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDSDtJQUVBLE9BQU9FLFNBQVN2QixJQUFVLEVBQVE7UUFDaEMsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0g7SUFFQSxPQUFPd0IsVUFBdUI7UUFDNUIsSUFBSSxLQUFrQixFQUFhLEVBVWxDO1FBQ0QsT0FBTztJQUNUO0lBRUEsT0FBT0csYUFBbUI7UUFDeEIsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0g7SUFFQSxPQUFPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ1AsV0FBVztRQUNoQixJQUFJLENBQUNNLFVBQVU7SUFDakI7QUFDRjtBQUVBLDZEQUE2RDtBQUN0RCxNQUFNRSxvQkFBb0IsQ0FBQ3BDLFdBQW1CakI7SUFDbkQsK0VBQStFO0lBQy9FLE9BQU9pQixXQUFXLDBEQUEwRDtBQUM5RSxFQUFFO0FBRUssTUFBTXFDLHlCQUF5QixDQUFDMUY7SUFDckMsT0FBTyxzQkFBc0IyRixJQUFJLENBQUMzRjtBQUNwQyxFQUFFO0FBRUYsNkVBQTZFO0FBQ3RFLE1BQU00RixvQkFBb0I7SUFDL0IsT0FBT0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUcsTUFDeENILEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLE1BQ3hDN0IsS0FBSzhCLEdBQUcsR0FBR0YsUUFBUSxDQUFDO0FBQzdCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbWVvbmVjaGFpbi1mcm9udGVuZC8uL2xpYi9hdXRoLnRzP2JmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29kZS9wb2MvZnJvbnRlbmQvbGliL2F1dGgudHNcbi8vIEZJWEVEIFZFUlNJT046IENvcnJlY3RlZCBBUEkgYmFzZSBVUkwgY29uZmlndXJhdGlvbiB0byBwcmV2ZW50IGRvdWJsZSAvYXBpLyBpc3N1ZVxuXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LWhvdC10b2FzdCc7XG5cbi8vIFR5cGVzIGZvciBhdXRoZW50aWNhdGlvblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICB1c2VybmFtZT86IHN0cmluZztcbiAgZGlzcGxheV9uYW1lPzogc3RyaW5nO1xuICBhdmF0YXJfdXJsPzogc3RyaW5nO1xuICB2ZXJpZmljYXRpb25fc3RhdHVzPzogJ2Jhc2ljJyB8ICd2ZXJpZmllZCcgfCAnZXhwZXJ0JztcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoU3RhdGUge1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgdXNlcjogVXNlciB8IG51bGw7XG4gIHRva2VuOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldEluZm8ge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIHB1YmxpY0tleT86IHN0cmluZztcbiAgcHJvdmlkZXI6ICdtZXRhbWFzaycgfCAnd2FsbGV0Y29ubmVjdCcgfCAnY29pbmJhc2UnIHwgJ21hbnVhbCc7XG59XG5cbi8vIFdhbGxldCBkZXRlY3Rpb24gYW5kIGNvbm5lY3Rpb24gdXRpbGl0aWVzXG5leHBvcnQgY2xhc3MgV2FsbGV0TWFuYWdlciB7XG4gIC8vIENoZWNrIGlmIE1ldGFNYXNrIGlzIGF2YWlsYWJsZVxuICBzdGF0aWMgaXNNZXRhTWFza0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgXG4gICAgICAgICAgIHR5cGVvZiAod2luZG93IGFzIGFueSkuZXRoZXJldW0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bS5pc01ldGFNYXNrO1xuICB9XG5cbiAgLy8gQ29ubmVjdCB0byBNZXRhTWFza1xuICBzdGF0aWMgYXN5bmMgY29ubmVjdE1ldGFNYXNrKCk6IFByb21pc2U8V2FsbGV0SW5mbz4ge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbi4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgICBcbiAgICAgIC8vIFJlcXVlc3QgYWNjb3VudCBhY2Nlc3NcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYWRkcmVzc2VzIHx8IGFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZC4gUGxlYXNlIHVubG9jayBNZXRhTWFzay4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3Nlc1swXTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBwdWJsaWMga2V5IGlmIGF2YWlsYWJsZSAob3B0aW9uYWwpXG4gICAgICBsZXQgcHVibGljS2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBwdWJsaWNLZXkgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXG4gICAgICAgICAgcGFyYW1zOiBbYWRkcmVzc11cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGdldCBwdWJsaWMga2V5OicsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIHByb3ZpZGVyOiAnbWV0YW1hc2snXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01ldGFNYXNrIGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCBNZXRhTWFzazogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNpZ24gYSBtZXNzYWdlIHdpdGggd2FsbGV0XG4gIHN0YXRpYyBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmlzTWV0YU1hc2tBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV0aGVyZXVtID0gKHdpbmRvdyBhcyBhbnkpLmV0aGVyZXVtO1xuICAgICAgXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBldGhlcmV1bS5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAncGVyc29uYWxfc2lnbicsXG4gICAgICAgIHBhcmFtczogW21lc3NhZ2UsIGFkZHJlc3NdXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNZXNzYWdlIHNpZ25pbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBhY2NvdW50IGNoYW5nZXNcbiAgc3RhdGljIG9uQWNjb3VudHNDaGFuZ2VkKGNhbGxiYWNrOiAoYWRkcmVzc2VzOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgIGlmICghdGhpcy5pc01ldGFNYXNrQXZhaWxhYmxlKCkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBldGhlcmV1bSA9ICh3aW5kb3cgYXMgYW55KS5ldGhlcmV1bTtcbiAgICBldGhlcmV1bS5vbignYWNjb3VudHNDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgIFxuICAgIC8vIFJldHVybiBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChldGhlcmV1bSAmJiBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBldGhlcmV1bS5yZW1vdmVMaXN0ZW5lcignYWNjb3VudHNDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIG5ldHdvcmsgY2hhbmdlc1xuICBzdGF0aWMgb25DaGFpbkNoYW5nZWQoY2FsbGJhY2s6IChjaGFpbklkOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICBpZiAoIXRoaXMuaXNNZXRhTWFza0F2YWlsYWJsZSgpKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZXRoZXJldW0gPSAod2luZG93IGFzIGFueSkuZXRoZXJldW07XG4gICAgZXRoZXJldW0ub24oJ2NoYWluQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gY2xlYW51cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZXRoZXJldW0gJiYgZXRoZXJldW0ucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgZXRoZXJldW0ucmVtb3ZlTGlzdGVuZXIoJ2NoYWluQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIEZJWEVEOiBDb3JyZWN0ZWQgVVJMIGRldGVjdGlvbiBhbmQgQVBJIGJhc2UgY29uZmlndXJhdGlvblxuY29uc3QgZ2V0QXBpQmFzZVVybCA9ICgpOiBzdHJpbmcgPT4ge1xuICAvLyBUcnkgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgY29uc3QgbmV4dFB1YmxpY1VybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gIGNvbnN0IHJlYWN0QXBwVXJsID0gcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0FQSV9VUkw7XG4gIFxuICBjb25zb2xlLmxvZygn8J+UpyBsaWIvYXV0aC50cyBFbnZpcm9ubWVudCBDaGVjazonLCB7XG4gICAgTkVYVF9QVUJMSUNfQVBJX1VSTDogbmV4dFB1YmxpY1VybCxcbiAgICBSRUFDVF9BUFBfQVBJX1VSTDogcmVhY3RBcHBVcmwsXG4gICAgTk9ERV9FTlY6IHByb2Nlc3MuZW52Lk5PREVfRU5WLFxuICAgIHdpbmRvd19sb2NhdGlvbjogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICdTU1InXG4gIH0pO1xuXG4gIC8vIEZJWEVEOiBVc2UgYmFja2VuZCBwb3J0IDMwMDEgKHdoZXJlIHlvdXIgRXhwcmVzcyBzZXJ2ZXIgcnVucykgV0lUSE9VVCBleHRyYSAvYXBpIHN1ZmZpeFxuICBjb25zdCBkZWZhdWx0VXJsID0gbmV4dFB1YmxpY1VybCB8fCByZWFjdEFwcFVybDtcbiAgXG4gIC8vIElmIG5vIGVudiB2YXIgaXMgc2V0LCBkZXRlY3QgQ29kZXNwYWNlcyBVUkwgb3IgdXNlIGxvY2FsaG9zdFxuICBpZiAoIWRlZmF1bHRVcmwpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgaWYgKGhvc3RuYW1lLmluY2x1ZGVzKCdnaXRodWIuZGV2JykgfHwgaG9zdG5hbWUuaW5jbHVkZXMoJ2dpdHBvZC5pbycpKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgQ29kZXNwYWNlcy9HaXRwb2QgYmFzZSBhbmQgcG9pbnQgdG8gYmFja2VuZCBwb3J0XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke2hvc3RuYW1lLnJlcGxhY2UoJy0zMDAwJywgJy0zMDAxJyl9YDtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7IC8vIEZJWEVEOiBSZXR1cm4gYmFzZSBVUkwgd2l0aG91dCAvYXBpIHN1ZmZpeFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7IC8vIEZJWEVEOiBCYWNrZW5kIHJ1bnMgb24gMzAwMSB3aXRob3V0IC9hcGkgc3VmZml4XG4gIH1cbiAgXG4gIC8vIEZJWEVEOiBFbnN1cmUgVVJMIGRvZXMgTk9UIGhhdmUgL2FwaSBzdWZmaXggKHdlJ2xsIGFkZCBpdCBpbiB0aGUgQVBJIGNhbGxzKVxuICBjb25zdCBiYXNlVXJsID0gZGVmYXVsdFVybC5yZXBsYWNlKC9cXC9hcGkuKiQvLCAnJyk7XG4gIGNvbnNvbGUubG9nKCfwn5SXIGxpYi9hdXRoLnRzIHVzaW5nIEFQSSBiYXNlIFVSTDonLCBiYXNlVXJsKTtcbiAgXG4gIHJldHVybiBiYXNlVXJsO1xufTtcblxuLy8gQXV0aGVudGljYXRpb24gQVBJIGNsaWVudFxuZXhwb3J0IGNsYXNzIEF1dGhBUEkge1xuICBwcml2YXRlIHN0YXRpYyBnZXQgYmFzZVVSTCgpIHtcbiAgICByZXR1cm4gZ2V0QXBpQmFzZVVybCgpO1xuICB9XG5cbiAgLy8gRklYRUQ6IEdlbmVyYXRlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSB3aXRoIGNvcnJlY3QgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIGdldEF1dGhDaGFsbGVuZ2Uod2FsbGV0QWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx7IGNoYWxsZW5nZTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlcjsgbm9uY2U6IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxVcmwgPSBgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL2NoYWxsZW5nZWA7XG4gICAgICBjb25zb2xlLmxvZygn8J+UkCBsaWIvYXV0aC50czogR2V0dGluZyBhdXRoIGNoYWxsZW5nZSBmcm9tOicsIGZ1bGxVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLCAvLyBGSVhFRDogSW5jbHVkZSBjcmVkZW50aWFscyBmb3IgQ09SU1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHdhbGxldEFkZHJlc3MgfSksIC8vIEZJWEVEOiBNYXRjaCBiYWNrZW5kIHBhcmFtZXRlciBuYW1lXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IENoYWxsZW5nZSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogQ2hhbGxlbmdlIGZhaWxlZDonLCByZXNwb25zZS5zdGF0dXMsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBhdXRoIGNoYWxsZW5nZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgbGliL2F1dGgudHM6IENoYWxsZW5nZSBkYXRhIHJlY2VpdmVkOicsIGRhdGEpO1xuICAgICAgXG4gICAgICAvLyBGSVhFRDogSGFuZGxlIGJhY2tlbmQgcmVzcG9uc2UgZm9ybWF0XG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbGxlbmdlOiBkYXRhLmNoYWxsZW5nZSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZXN0YW1wLFxuICAgICAgICAgIG5vbmNlOiBkYXRhLm5vbmNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBhdXRoIGNoYWxsZW5nZSBlbmRwb2ludCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogQXV0aCBjaGFsbGVuZ2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGF1dGggY2hhbGxlbmdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRklYRUQ6IFZlcmlmeSBzaWduYXR1cmUgd2l0aCBjb3JyZWN0IGVuZHBvaW50XG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlTaWduYXR1cmUoXG4gICAgd2FsbGV0QWRkcmVzczogc3RyaW5nLCBcbiAgICBzaWduYXR1cmU6IHN0cmluZywgXG4gICAgY2hhbGxlbmdlOiBzdHJpbmcsXG4gICAgdGltZXN0YW1wPzogbnVtYmVyLFxuICAgIG5vbmNlPzogc3RyaW5nXG4gICk6IFByb21pc2U8eyB0b2tlbjogc3RyaW5nOyB1c2VyOiBVc2VyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvbG9naW5gO1xuICAgICAgY29uc29sZS5sb2coJ/CflJAgbGliL2F1dGgudHM6IFZlcmlmeWluZyBzaWduYXR1cmUgYXQ6JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsIC8vIEZJWEVEOiBJbmNsdWRlIGNyZWRlbnRpYWxzIGZvciBDT1JTXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgd2FsbGV0QWRkcmVzcywgXG4gICAgICAgICAgc2lnbmF0dXJlLCBcbiAgICAgICAgICBjaGFsbGVuZ2UsXG4gICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgIG5vbmNlXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SQIGxpYi9hdXRoLnRzOiBWZXJpZnkgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGVycm9yOiByZXNwb25zZS5zdGF0dXNUZXh0IH0pKTtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIGxpYi9hdXRoLnRzOiBWZXJpZnkgZmFpbGVkOicsIGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yRGF0YS5lcnJvciB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBsaWIvYXV0aC50czogVmVyaWZ5IGRhdGEgcmVjZWl2ZWQ6JywgZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEZJWEVEOiBIYW5kbGUgYmFja2VuZCByZXNwb25zZSBmb3JtYXRcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS50b2tlbiAmJiBkYXRhLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbjogZGF0YS50b2tlbixcbiAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxuICAgICAgICAgICAgYWRkcmVzczogZGF0YS51c2VyLndhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5wc2V1ZG9ueW0gfHwgYFVzZXIgJHtkYXRhLnVzZXIud2FsbGV0QWRkcmVzcy5zbGljZSgtNCl9YCxcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbl9zdGF0dXM6ICdiYXNpYycsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBhdXRoIHZlcmlmeSBlbmRwb2ludCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBsaWIvYXV0aC50czogU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWEVEOiBHZXQgY3VycmVudCB1c2VyIGluZm8gd2l0aCBjb3JyZWN0IGVuZHBvaW50XG4gIHN0YXRpYyBhc3luYyBnZXRDdXJyZW50VXNlcih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZ1bGxVcmwgPSBgJHt0aGlzLmJhc2VVUkx9L2FwaS9hdXRoL21lYDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIGxpYi9hdXRoLnRzOiBHZXR0aW5nIGN1cnJlbnQgdXNlciBmcm9tOicsIGZ1bGxVcmwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgdXNlciBpbmZvOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIC8vIEZJWEVEOiBIYW5kbGUgYmFja2VuZCByZXNwb25zZSBmb3JtYXRcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS51c2VyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICBhZGRyZXNzOiBkYXRhLnVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEudXNlci5wc2V1ZG9ueW0gfHwgYFVzZXIgJHtkYXRhLnVzZXIud2FsbGV0QWRkcmVzcy5zbGljZSgtNCl9YCxcbiAgICAgICAgICB2ZXJpZmljYXRpb25fc3RhdHVzOiAnYmFzaWMnLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGRhdGEudXNlci5jcmVhdGVkX2F0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnSW52YWxpZCB1c2VyIGRhdGEgcmVjZWl2ZWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdHZXQgY3VycmVudCB1c2VyIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB1c2VyIGluZm86ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBGSVhFRDogVmVyaWZ5IEpXVCB0b2tlbiB3aXRoIGNvcnJlY3QgZW5kcG9pbnRcbiAgc3RhdGljIGFzeW5jIHZlcmlmeVRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW47IHVzZXI/OiBVc2VyIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFVybCA9IGAke3RoaXMuYmFzZVVSTH0vYXBpL2F1dGgvdmVyaWZ5YDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIGxpYi9hdXRoLnRzOiBWZXJpZnlpbmcgdG9rZW4gYXQ6JywgZnVsbFVybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4gfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2VzcyAmJiBkYXRhLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgdXNlcjogZGF0YS51c2VyID8ge1xuICAgICAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEudXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBkYXRhLnVzZXIucHNldWRvbnltIHx8IGBVc2VyICR7ZGF0YS51c2VyLndhbGxldEFkZHJlc3Muc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25fc3RhdHVzOiAnYmFzaWMnLFxuICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTG9jYWwgc3RvcmFnZSB1dGlsaXRpZXNcbmV4cG9ydCBjbGFzcyBBdXRoU3RvcmFnZSB7XG4gIHByaXZhdGUgc3RhdGljIFRPS0VOX0tFWSA9ICdvbWVvbmVfYXV0aF90b2tlbic7XG4gIHByaXZhdGUgc3RhdGljIFVTRVJfS0VZID0gJ29tZW9uZV91c2VyJztcblxuICBzdGF0aWMgc2F2ZVRva2VuKHRva2VuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuVE9LRU5fS0VZLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlVG9rZW4oKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRPS0VOX0tFWSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNhdmVVc2VyKHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuVVNFUl9LRVksIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0VXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVVNFUl9LRVkpO1xuICAgICAgaWYgKHVzZXJEYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodXNlckRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdG9yZWQgdXNlciBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVVc2VyKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5VU0VSX0tFWSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMucmVtb3ZlVG9rZW4oKTtcbiAgICB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgfVxufVxuXG4vLyBGSVhFRDogVXRpbGl0eSBmdW5jdGlvbnMgdG8gbWF0Y2ggYmFja2VuZCBjaGFsbGVuZ2UgZm9ybWF0XG5leHBvcnQgY29uc3QgY3JlYXRlQXV0aE1lc3NhZ2UgPSAoY2hhbGxlbmdlOiBzdHJpbmcsIHdhbGxldEFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBjaGFsbGVuZ2UgbWVzc2FnZSBmb3JtYXQgZnJvbSB5b3VyIGJhY2tlbmQgYXV0aCByb3V0ZXNcbiAgcmV0dXJuIGNoYWxsZW5nZTsgLy8gQmFja2VuZCBhbHJlYWR5IHByb3ZpZGVzIHRoZSBjb21wbGV0ZSBmb3JtYXR0ZWQgbWVzc2FnZVxufTtcblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRFdGhlcmV1bUFkZHJlc3MgPSAoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgcmFuZG9tIGNoYWxsZW5nZSBzdHJpbmcgKGZhbGxiYWNrIC0gYmFja2VuZCBzaG91bGQgaGFuZGxlIHRoaXMpXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVDaGFsbGVuZ2UgPSAoKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBcbiAgICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSkgKyBcbiAgICAgICAgIERhdGUubm93KCkudG9TdHJpbmcoMzYpO1xufTsiXSwibmFtZXMiOlsiV2FsbGV0TWFuYWdlciIsImlzTWV0YU1hc2tBdmFpbGFibGUiLCJ3aW5kb3ciLCJldGhlcmV1bSIsImlzTWV0YU1hc2siLCJjb25uZWN0TWV0YU1hc2siLCJFcnJvciIsImFkZHJlc3NlcyIsInJlcXVlc3QiLCJtZXRob2QiLCJsZW5ndGgiLCJhZGRyZXNzIiwicHVibGljS2V5IiwicGFyYW1zIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwidG9Mb3dlckNhc2UiLCJwcm92aWRlciIsIm1lc3NhZ2UiLCJzaWduTWVzc2FnZSIsInNpZ25hdHVyZSIsIm9uQWNjb3VudHNDaGFuZ2VkIiwiY2FsbGJhY2siLCJvbiIsInJlbW92ZUxpc3RlbmVyIiwib25DaGFpbkNoYW5nZWQiLCJnZXRBcGlCYXNlVXJsIiwibmV4dFB1YmxpY1VybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwicmVhY3RBcHBVcmwiLCJSRUFDVF9BUFBfQVBJX1VSTCIsIk5PREVfRU5WIiwid2luZG93X2xvY2F0aW9uIiwibG9jYXRpb24iLCJocmVmIiwiZGVmYXVsdFVybCIsImhvc3RuYW1lIiwiaW5jbHVkZXMiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiQXV0aEFQSSIsImJhc2VVUkwiLCJnZXRBdXRoQ2hhbGxlbmdlIiwid2FsbGV0QWRkcmVzcyIsImZ1bGxVcmwiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsImNyZWRlbnRpYWxzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGF0dXMiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwiY2hhbGxlbmdlIiwidGltZXN0YW1wIiwibm9uY2UiLCJ2ZXJpZnlTaWduYXR1cmUiLCJlcnJvckRhdGEiLCJjYXRjaCIsInRva2VuIiwidXNlciIsImlkIiwiZGlzcGxheV9uYW1lIiwicHNldWRvbnltIiwic2xpY2UiLCJ2ZXJpZmljYXRpb25fc3RhdHVzIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImdldEN1cnJlbnRVc2VyIiwidmVyaWZ5VG9rZW4iLCJ2YWxpZCIsInVuZGVmaW5lZCIsIkF1dGhTdG9yYWdlIiwiVE9LRU5fS0VZIiwiVVNFUl9LRVkiLCJzYXZlVG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0VG9rZW4iLCJnZXRJdGVtIiwicmVtb3ZlVG9rZW4iLCJyZW1vdmVJdGVtIiwic2F2ZVVzZXIiLCJnZXRVc2VyIiwidXNlckRhdGEiLCJwYXJzZSIsInJlbW92ZVVzZXIiLCJjbGVhciIsImNyZWF0ZUF1dGhNZXNzYWdlIiwiaXNWYWxpZEV0aGVyZXVtQWRkcmVzcyIsInRlc3QiLCJnZW5lcmF0ZUNoYWxsZW5nZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./lib/auth.ts\n");

/***/ })

};
;